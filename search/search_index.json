{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Build workflows for your Relays","text":"<p>A module for implementing Relay workflows in Python. This is the SDK that provides a way for your enterprise to extend your I/T tools to your active workers via Relay devices. There are APIs for text-to-speech (say), speech-to-text (listen), LED control, vibration control, location information, NFC tag taps, etc. See https://developer.relaypro.com</p>"},{"location":"#relay.workflow.Relay","title":"<code>Relay</code>","text":"<p>Includes the main functionalities that are used within workflows, such as functions for communicating with the device, sending out notifications to groups, handling workflow events, and performing physical actions on the device such as manipulating LEDs and creating vibrations.</p> Source code in <code>relay/workflow.py</code> <pre><code>class Relay:\n\"\"\"Includes the main functionalities that are used within workflows,\n    such as functions for communicating with the device, sending out\n    notifications to groups, handling workflow events, and performing physical actions\n    on the device such as manipulating LEDs and creating vibrations.\n    \"\"\"\n\n    def __init__(self, workflow: Workflow):\n\"\"\"Initializes workflow fields.\n\n        Args:\n            workflow (Workflow): your workflow.\n        \"\"\"\n        self.workflow = workflow\n        self.websocket = None\n        self.id_futures = {}  # {_id: future}\n        self.event_futures = {}\n        self.logger = None\n\n    def _get_cid(self):\n        # correlation id\n        return f'{self.workflow.name}:{id(self.websocket)}'\n\n    def _from_json(self, websocket_message):\n        dict_message = json.loads(websocket_message)\n        return self._clean_int_arrays(dict_message)\n\n    def _clean_int_arrays(self, dict_message):\n        # work around the JSON formatting issue in iBot\n        # that gives us an array of ints instead of a string:\n        # will be fixed in iBot 3.10 via PE-17571\n\n        if isinstance(dict_message, dict):\n            for key in dict_message.keys():\n                if isinstance(dict_message[key], (list, dict)):\n                    dict_message[key] = self._clean_int_arrays(dict_message[key])\n        elif isinstance(dict_message, list):\n            all_int = True\n            for item in dict_message:\n                if not isinstance(item, int):\n                    all_int = False\n                    break\n            if all_int and (len(dict_message) &gt; 0):\n                dict_message = \"\".join(chr(i) for i in dict_message)\n        return dict_message\n\n    @staticmethod\n    def _validate_trigger(trigger: dict):\n        if not isinstance(trigger, dict):\n            raise WorkflowException('trigger parameter is not a dictionary')\n        if 'args' not in trigger:\n            raise WorkflowException('trigger parameter is not a trigger dictionary')\n        if 'source_uri' not in trigger['args']:\n            raise WorkflowException('there is no source_uri definition in the trigger')\n\n    @staticmethod\n    def make_target_uris(trigger: dict):\n\"\"\"Creates a target URN after receiving a workflow trigger.\n\n        Args:\n            trigger (dict): workflow trigger.\n\n        Raises:\n            WorkflowException: thrown if the trigger param is not a dictionary.\n            WorkflowException: thrown if the trigger param is not a trigger dictionary.\n            WorkflowException: thrown if there is no source_uri definition in the trigger.\n\n        Returns:\n            a target object created from the trigger.\n        \"\"\"\n        Relay._validate_trigger(trigger)\n        target = {\n            'uris': [trigger['args']['source_uri']]\n        }\n        return target\n\n    @staticmethod\n    def get_source_uri_from_trigger(trigger: dict) -&gt; str:\n\"\"\"Get the source URN from a workflow trigger\n\n        Args:\n            trigger (dict): workflow trigger.\n\n        Raises:\n            WorkflowException: thrown if the trigger param is not a dictionary.\n            WorkflowException: thrown if the trigger param is not a trigger dictionary.\n            WorkflowException: thrown if there is no source_uri definition in the trigger.\n\n        Returns:\n            the source URN as a string from the trigger.\n\n        \"\"\"\n        Relay._validate_trigger(trigger)\n        source_uri = trigger['args']['source_uri']\n        return source_uri\n\n    @staticmethod\n    def targets_from_source_uri(source_uri: str):\n\"\"\"Creates a target object from a source URN.\n        Enables the device to perform the desired action after the function\n        has been called.  Used interanlly by interaction functions such as\n        say(), listen(), vibration(), etc.\n\n        Args:\n            source_uri (str): source uri that will be used to create a target.\n\n        Returns:\n            the target that was created from a source URN.\n        \"\"\"\n        targets = {\n            'uris': [source_uri]\n        }\n        return targets\n\n    async def _handle(self, websocket):\n\n        self.websocket = websocket\n        self.logger = CustomAdapter(logger, {'cid': self._get_cid()})\n\n        self.logger.info(f'workflow instance started for {self.websocket.path}')\n\n        try:\n            async for m in websocket:\n                # TODO: restore after PE-17571\n                # self.logger.debug(f'recv raw: {m}')\n                e = self._from_json(m)\n                self.logger.debug(f'recv: {e}')\n\n                _id = e.get('_id', None)\n                _type = e.get('_type', None)\n\n                fut = self.id_futures.pop(_id, None)\n                if fut:\n                    fut.set_result(e)\n\n                else:\n                    handled = False\n                    future = self._pop_event_match(e)\n                    if future:\n                        future.set_result(e)\n                        handled = True\n\n                    # events that don't have an _id field (some events do have an _id field for async response data)\n                    h = self.workflow.get_handler(e)\n                    if h:\n                        if _type == 'wf_api_start_event':\n                            asyncio.create_task(self._wrapper(h, e['trigger']))\n\n                        elif _type == 'wf_api_stop_event':\n                            asyncio.create_task(self._wrapper(h, e['reason']))\n\n                        elif _type == 'wf_api_prompt_event':\n                            asyncio.create_task(self._wrapper(h, e['source_uri'], e['type']))\n\n                        elif _type == 'wf_api_button_event':\n                            asyncio.create_task(self._wrapper(h, e['button'], e['taps'], e['source_uri']))\n\n                        elif _type == 'wf_api_notification_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['event'], e['name'], e['notification_state'], e['source_uri']))\n\n                        elif _type == 'wf_api_timer_event':\n                            asyncio.create_task(self._wrapper(h))\n\n                        elif _type == 'wf_api_timer_fired_event':\n                            asyncio.create_task(self._wrapper(h, e['name']))\n\n                        elif _type == 'wf_api_speech_event':\n                            text = e['text'] if 'text' in e else None\n                            audio = e['audio'] if 'audio' in e else None\n                            asyncio.create_task(\n                                self._wrapper(h, text, audio, e['lang'], e['request_id'], e['source_uri']))\n\n                        elif _type == 'wf_api_progress_event':\n                            asyncio.create_task(self._wrapper(h))\n\n                        elif _type == 'wf_api_play_inbox_message_event':\n                            asyncio.create_task(self._wrapper(h, e['action']))\n\n                        elif _type == 'wf_api_call_connected_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['call_id'], e['direction'], e['device_id'], e['device_name'],\n                                              e['uri'], e['onnet'], e['start_time_epoch'], e['connect_time_epoch']))\n\n                        elif _type == 'wf_api_call_disconnected_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['call_id'], e['direction'], e['device_id'], e['device_name'],\n                                              e['uri'], e['onnet'], e['reason'], e['start_time_epoch'],\n                                              e['connect_time_epoch'], e['end_time_epoch']))\n\n                        elif _type == 'wf_api_call_failed_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['call_id'], e['direction'], e['device_id'], e['device_name'],\n                                              e['uri'], e['onnet'], e['reason'], e['start_time_epoch'],\n                                              e['connect_time_epoch'], e['end_time_epoch']))\n\n                        elif _type == 'wf_api_call_received_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['call_id'], e['direction'], e['device_id'], e['device_name'],\n                                              e['uri'], e['onnet'], e['start_time_epoch']))\n\n                        elif _type == 'wf_api_call_ringing_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['call_id'], e['direction'], e['device_id'], e['device_name'],\n                                              e['uri'], e['onnet'], e['start_time_epoch']))\n\n                        elif _type == 'wf_api_call_progressing_event':\n                            asyncio.create_task(\n                                self._wrapper(h, e['call_id'], e['direction'], e['device_id'], e['device_name'],\n                                              e['uri'], e['onnet'], e['start_time_epoch'], e['connect_time_epoch']))\n\n                        elif _type == 'wf_api_call_start_request_event':\n                            asyncio.create_task(self._wrapper(h, e['uri']))\n\n                        elif _type == 'wf_api_sms_event':\n                            asyncio.create_task(self._wrapper(h, e['id'], e['event']))\n\n                        elif _type == 'wf_api_incident_event':\n                            asyncio.create_task(self._wrapper(h, e['type'], e['incident_id'], e['reason']))\n\n                        elif _type == 'wf_api_interaction_lifecycle_event':\n                            reason = e['reason'] if 'reason' in e else None\n                            asyncio.create_task(self._wrapper(h, e['type'], e['source_uri'], reason))\n\n                        elif _type == 'wf_api_resume_event':\n                            asyncio.create_task(self._wrapper(h, e['trigger']))\n\n                    elif not handled:\n                        if (_type == 'wf_api_prompt_event') or (_type == 'wf_api_speech_event') or (\n                                _type == 'wf_api_stop_event'):\n                            level = logging.DEBUG\n                        else:\n                            level = logging.WARNING\n                        self.logger.log(level, f'no handler found for _type {e[\"_type\"]}')\n        # the \"exceptions\" module is really what we receive\n        except websockets.exceptions.ConnectionClosedError:\n            # ibot closes the connection on terminate(); this is expected\n            pass\n\n        except Exception as x:\n            self.logger.error(f'{x}', exc_info=True)\n\n        finally:\n            self.logger.info('workflow instance terminated')\n\n    # run handlers with exception logging; needed since we cannot await handlers\n    async def _wrapper(self, h, *args):\n        try:\n            await h(self, *args)\n        except Exception as x:\n            self.logger.error(f'{x}', exc_info=True)\n\n    async def _send(self, obj):\n        _id = uuid.uuid4().hex\n        obj['_id'] = _id\n\n        # TODO: ibot add responses to all _request events? if so, await them here ... and check for error responses\n\n        await self._send_str(json.dumps(obj))\n\n    async def _send_receive(self, obj, uid=None):\n        _id = uid if uid else uuid.uuid4().hex\n        obj['_id'] = _id\n        fut = asyncio.get_event_loop().create_future()\n        self.id_futures[_id] = fut\n\n        # TODO: ibot currently loads null as the string 'null'\n        await self._send_str(json.dumps(remove_null(obj)))\n        # wait on the response\n        await fut\n        rsp = fut.result()\n        if rsp['_type'] == 'wf_api_error_response':\n            raise WorkflowException(rsp['error'])\n        return fut.result()\n\n    async def _send_str(self, s):\n        self.logger.debug(f'send: {s}')\n        await self.websocket.send(s)\n\n    async def get_var(self, name: str, default=None):\n\"\"\"Retrieves a variable that was set either during workflow registration\n        or through the set_var() function.  The variable can be retrieved anywhere\n        within the workflow, but is erased after the workflow terminates.\n\n        Args:\n            name (str): name of the variable to be retrieved.\n            default (optional): default value of the variable if it does not exist. Defaults to None.\n\n        Returns:\n            the variable requested.\n        \"\"\"\n        # TODO: look in self.workflow.state to see all of what is available\n        event = {\n            '_type': 'wf_api_get_var_request',\n            'name': name\n        }\n        v = await self._send_receive(event)\n        return v.get('value', default)\n\n    async def get_number_var(self, name: str, default=None):\n\"\"\"Retrieves a variable that was set either during workflow registration\n        or through the set_var() function of type integer.  The variable can be retrieved anywhere\n        within the workflow, but is erased after the workflow terminates.\n\n        Args:\n            name (str): name of the variable to be retrieved.\n            default (optional): default value of the variable if it does not exist. Defaults to None.\n\n        Returns:\n            the variable requested.\n        \"\"\"\n        return int(await self.get_var(name, default))\n\n    async def set_var(self, name: str, value: str):\n\"\"\"Sets a variable with the corresponding name and value. Scope of\n        the variable is from start to end of a workflow.  Note that you \n        can only set values of type string.\n        Args:\n            name (str): name of the variable to be created.\n            value (str): value that the variable will hold.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_set_var_request',\n            'name': name,\n            'value': value\n        }\n        response = await self._send_receive(event)\n        return response['value']\n\n    async def unset_var(self, name: str):\n\"\"\"Unsets the value of a variable.  \n\n        Args:\n            name (str): the name of the variable whose value you would like to unset.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_unset_var_request',\n            'name': name\n        }\n        await self._send_receive(event)\n\n    @staticmethod\n    def interaction_options(color: str = \"0000ff\", input_types: list = None, home_channel: str = \"suspend\"):\n\"\"\"Options for when an interaction is started via a workflow.\n\n        Args:\n            color (str, optional): desired color of LEDs when an interaction is started. Defaults to \"0000ff\".\n            input_types (list, optional): input types you would like for the interaction. Defaults to an empty list.\n            home_channel (str, optional): home channel for the device during the interaction. Defaults to \"suspend\".\n\n        Returns:\n            the options specified.\n        \"\"\"\n        if input_types is None:\n            input_types = []\n        options = {\n            'color': color,\n            'input_types': input_types,\n            'home_channel': home_channel\n        }\n        return options\n\n    async def start_interaction(self, target, name: str, options=None):\n\"\"\"Starts an interaction with the user.  Triggers an INTERACTION_STARTED event\n        and allows the user to interact with the device via functions that require an \n        interaction URN.\n\n        Args:\n            target (target): the device that you would like to start an interaction with.\n            name (str): a name for your interaction.\n            options (optional): can be color, home channel, or input types. Defaults to None.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_start_interaction_request',\n            '_target': target,\n            'name': name,\n            'options': options\n        }\n        await self._send_receive(event)\n\n    async def end_interaction(self, target):\n\"\"\"Ends an interaction with the user.  Triggers an INTERACTION_ENDED event to signify\n        that the user is done interacting with the device.\n\n        Args:\n            target(str): the interaction that you would like to end.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_end_interaction_request',\n            '_target': self.targets_from_source_uri(target)\n        }\n        await self._send_receive(event)\n\n    def _set_event_match(self, criteria: dict):\n        if not isinstance(criteria, dict):\n            raise WorkflowException(\"criteria is not a dict\")\n        match_data = criteria.copy()\n        uid = uuid.uuid4().hex\n        future = asyncio.get_event_loop().create_future()\n        match_data['_timestamp'] = time.time()\n        match_data['_future'] = future\n        self.event_futures[uid] = match_data\n        return future\n\n    @staticmethod\n    async def _wait_for_event_match(future, timeout: int):\n        await asyncio.wait_for(future, timeout)\n        event = future.result()\n        if event['_type'] == 'wf_api_error_response':\n            raise WorkflowException(event['error'])\n        return event\n\n    def _pop_event_match(self, event):\n        # check if event matches anything we are waiting for\n        now = time.time()\n        for uid in self.event_futures:\n            # purge old items (30 minutes)\n            age = now - self.event_futures[uid]['_timestamp']\n            if age &gt; 1800:\n                self.event_futures.pop(uid, None)\n                continue\n            matches = True\n            criteria = self.event_futures[uid]\n            for key in criteria:\n                if key == '_timestamp' or key == '_future':\n                    continue\n                # if event doesn't have criteria item, then fail\n                if key not in event:\n                    matches = False\n                    break\n                if self.event_futures[uid][key] != event[key]:\n                    matches = False\n                    break\n            if matches:\n                future = self.event_futures[uid]['_future']\n                self.event_futures.pop(uid, None)\n                return future\n        return None\n\n    async def listen(self, target, phrases=None, transcribe: bool = True, alt_lang: str = None, timeout: int = 60):\n\"\"\"Listens for the user to speak into the device.  Utilizes speech to text functionality to interact\n        with the user.\n\n        Args:\n            target (str): the interaction URN.\n            phrases (string[], optional): optional phrases that you would like to limit the user's response to.\n             Defaults to None.\n            transcribe (bool, optional): whether you would like to transcribe the user's reponse. Defaults to True.\n            timeout (int, optional): timeout for how long the device will wait for user's response. Defaults to 60.\n            alt_lang (str, optional): if you would like the device to listen for a response in a specific language.\n             Defaults to None.\n\n        Returns:\n            text representation of what the user had spoken into the device.\n        \"\"\"\n        if phrases is None:\n            phrases = []\n        if isinstance(phrases, str):\n            phrases = [phrases]\n\n        _id = uuid.uuid4().hex\n        event = {\n            '_type': 'wf_api_listen_request',\n            '_target': self.targets_from_source_uri(target),\n            'phrases': phrases,\n            'transcribe': transcribe,\n            'timeout': timeout,\n            'alt_lang': alt_lang\n        }\n\n        criteria = {\n            '_type': 'wf_api_speech_event',\n            'request_id': _id\n        }\n        # need to add this before _send_receive to avoid race condition\n        event_future = self._set_event_match(criteria)\n        await self._send_receive(event, _id)\n        speech_event = await self._wait_for_event_match(event_future, timeout)\n\n        if transcribe:\n            return speech_event['text']\n        else:\n            return speech_event['audio']\n\n    async def play(self, target, filename: str):\n\"\"\"Plays a custom audio file that was uploaded by the user.\n\n        Args:\n            target(str): the interaction URN.\n            filename (str): the name of the audio file.\n\n        Returns:\n            the response id after the audio file has been played on the device.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_play_request',\n            '_target': self.targets_from_source_uri(target),\n            'filename': filename\n        }\n        response = await self._send_receive(event)\n        return response['id']\n\n    async def play_and_wait(self, target, filename: str):\n\"\"\"Plays a custom audio file that was uploaded by the user.\n        Waits until the audio file has finished playing before continuing through\n        the workflow.\n\n        Args:\n            target(str): the interaction URN.\n            filename (str): the name of the audio file.\n\n        Returns:\n            the response id after the audio file has been played on the device.\n        \"\"\"\n        _id = uuid.uuid4().hex\n        event = {\n            '_type': 'wf_api_play_request',\n            '_target': self.targets_from_source_uri(target),\n            'filename': filename\n        }\n\n        criteria = {\n            '_type': 'wf_api_prompt_event',\n            'type': 'stopped',\n            'id': _id\n        }\n\n        event_future = self._set_event_match(criteria)\n        response = await self._send_receive(event, _id)\n        await self._wait_for_event_match(event_future, 30)\n        return response['id']\n\n    async def say(self, target, text: str, lang: str = 'en-US'):\n\"\"\"Utilizes text to speech capabilities to make the device 'speak' to the user.\n\n        Args:\n            target(str): the interaction URN.\n            text (str): what you would like the device to say.\n            lang (str, optional): the language of the text that is being spoken. Defaults to 'en-US'.\n\n        Returns:\n            the response ID after the device speaks to the user.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_say_request',\n            '_target': self.targets_from_source_uri(target),\n            'text': text,\n            'lang': lang\n        }\n        response = await self._send_receive(event)\n        return response['id']\n\n    async def say_and_wait(self, target, text: str, lang: str = 'en-US'):\n\"\"\"Utilizes text to speech capabilities to make the device 'speak' to the user.\n        Waits until the text is fully played out on the device before continuing.\n\n        Args:\n            target(str): the interaction URN.\n            text (str): what you would like the device to say.\n            lang (str, optional): the language of the text that is being spoken. Defaults to 'en-US'.\n\n        Returns:\n            the response ID after the device speaks to the user.\n        \"\"\"\n        _id = uuid.uuid4().hex\n        event = {\n            '_type': 'wf_api_say_request',\n            '_target': self.targets_from_source_uri(target),\n            'text': text,\n            'lang': lang\n        }\n\n        criteria = {\n            '_type': 'wf_api_prompt_event',\n            'type': 'stopped',\n            'id': _id}\n\n        event_future = self._set_event_match(criteria)\n        response = await self._send_receive(event, _id)\n        await self._wait_for_event_match(event_future, 30)\n        logger.debug(f'wait complete for {target}')\n        return response['id']\n\n    @staticmethod\n    def push_options(priority: str = 'normal', title: str = None, body: str = None, sound: str = 'default'):\n\"\"\"Push options for a virtual device after receiving a notification on the Relay App.\n\n        Args:\n            priority (str, optional): priority of the notification. Can be 'normal', 'high', or 'critical'.\n             Defaults to 'normal'.\n            title (str, optional): title of the notification. Defaults to None.\n            body (str, optional): body of the notification. Defaults to None.\n            sound (str, optional): sound to be played when notification appears on app. Can be 'default', or 'sos'.\n              Defaults to 'default'.\n\n        Returns:\n            the options for priority and sound as specified.\n        \"\"\"\n\n        options = {\n            'priority': priority,\n            'sound': sound\n        }\n        if title is not None:\n            options['title'] = title\n        if body is not None:\n            options['body'] = body\n        return options\n\n    # target properties: uri: array of string ids\n\n    # repeating tone plus tts until button press\n    async def alert(self, target, originator: str, name: str, text: str, push_opts: dict = None):\n\"\"\"Sends out an alert to the specified group of devices and the Relay Dash.\n\n        Args:\n            target(str): the group URN that you would like to send an alert to.\n            originator (str): the URN of the device that triggered the alert.\n            name (str): a name for your alert.\n            text (str): the text that you would like to be spoken to the group as your alert.\n            push_opts (dict, optional): push options for if the alert is sent to the Relay app on a virtual device.\n             Defaults to an empty value.\n        \"\"\"\n        if push_opts is None:\n            push_opts = {}\n        await self._send_notification(target, originator, 'alert', text, name, push_opts)\n\n    async def cancel_alert(self, target, name: str):\n\"\"\"Cancels an alert that was sent to a group of devices.  Particularly useful if you would like to cancel\n         the alert on all devices after one device has acknowledged the alert.\n\n        Args:\n            target(str): the device URN that has acknowledged the alert.\n            name (str): the name of the alert.\n        \"\"\"\n        await self._send_notification(target, None, 'cancel', None, name)\n\n    async def broadcast(self, target, originator: str, name: str, text: str, push_opts: dict = None):\n\"\"\"Sends out a broadcast message to a group of devices.  The message is played out on\n        all devices, as well as sent to the Relay Dash.\n\n        Args:\n            target(str): the group URN that you would like to broadcast your message to.\n            originator (str): the device URN that triggered the broadcast.\n            name (str): a name for your broadcast.\n            text (str): the text that you would like to be broadcasted to your group.\n            push_opts (dict, optional): push options for if the broadcast is sent to the Relay app on a virtual\n             device. Defaults to an empty value.\n        \"\"\"\n        if push_opts is None:\n            push_opts = {}\n        await self._send_notification(target, originator, 'broadcast', text, name, push_opts)\n\n    async def cancel_broadcast(self, target, name: str):\n\"\"\"Cancels the broadcast that was sent to a group of devices.\n\n        Args:\n            target(str): the device URN that is cancelling the broadcast.\n            name (str): the name of the broadcast that you would like to cancel.\n        \"\"\"\n        await self._send_notification(target, None, 'cancel', None, name)\n\n    async def _send_notification(self, target, originator: Union[str, None], ntype: str,\n                                 text: Union[str, None], name: str, push_opts: dict = None):\n\"\"\"Used for sending a notification on the server.  Private method that is\n        used by alert() and broadcast().\n\n        Args:\n            target (str): the group URN that you are sending a notification to.\n            originator (str): the device that triggered the notification.\n            ntype (str): the type of notification, either 'alert' or 'broadcast'.\n            name (str): a name for your notification.\n            text (str): the text of your notification.\n            push_opts (dict, optional): allows you to customize the push notification sent to a virtual device.\n             Defaults to None.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_notification_request',\n            '_target': self.targets_from_source_uri(target),\n            'originator': originator,\n            'type': ntype,\n            'name': name,\n            'text': text,\n            'target': self.targets_from_source_uri(target),\n            'push_opts': push_opts\n        }\n        await self._send_receive(event)\n\n    async def set_channel(self, target, channel_name: str, suppress_tts: bool = False,\n                          disable_home_channel: bool = False):\n\"\"\"Sets the channel that a device is on.  This can be used to change the channel of a device during a workflow,\n        where the channel will also be updated on the Relay Dash.\n\n        Args:\n            target (str): the device or interaction URN.\n            channel_name (str): the name of the channel you would like to set your device to.\n            suppress_tts (bool, optional): whether you would like to surpress text to speech. Defaults to False.\n            disable_home_channel (bool, optional): whether you would like to disable the home channel.\n             Defaults to False.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_set_channel_request',\n            '_target': self.targets_from_source_uri(target),\n            'channel_name': channel_name,\n            'suppress_tts': suppress_tts,\n            'disable_home_channel': disable_home_channel\n        }\n        await self._send_receive(event)\n\n    async def get_device_name(self, target):\n\"\"\"Returns the name of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n\n        Returns:\n            str: the name of the device.\n        \"\"\"\n        v = await self._get_device_info(target, 'name')\n        return v['name']\n\n    async def get_device_address(self, target, refresh: bool = False):\n\"\"\"Returns the address of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n            refresh (bool, optional): whether you would like to refresh before retrieving the address.\n             Defaults to False.\n\n        Returns:\n            str: the address of the device.\n        \"\"\"\n        return await self.get_device_location(target, refresh)\n\n    async def get_device_location(self, target, refresh: bool = False):\n\"\"\"Returns the location of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n            refresh (bool, optional): whether you would like to refresh before retrieving the location.\n             Defaults to False.\n\n        Returns:\n            str: the location of the device.\n        \"\"\"\n        v = await self._get_device_info(target, 'address', refresh)\n        return v['address']\n\n    async def get_device_latlong(self, target, refresh: bool = False):\n\"\"\"Returns the latitude and longitude coordinates of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n            refresh (bool, optional): whether you would like to refresh before retrieving the coordinates.\n             Defaults to False.\n\n        Returns:\n            float[]: an array containing the latitude and longitude of the device.\n        \"\"\"\n        return await self.get_device_coordinates(target, refresh)\n\n    async def get_device_coordinates(self, target, refresh: bool = False):\n\"\"\"Retrieves the coordinates of the device's location.\n\n        Args:\n            target (str): the device or interaction URN.\n            refresh (bool, optional): whether you would like to refresh before retreiving the coordinates.\n             Defaults to False.\n        \"\"\"\n        v = await self._get_device_info(target, 'latlong', refresh)\n        return v['latlong']\n\n    async def get_device_indoor_location(self, target, refresh: bool = False):\n\"\"\"Returns the indoor location of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n            refresh (bool, optional): whether you would like to refresh before retrieving the location.\n             Defaults to False.\n\n        Returns:\n            str: the indoor location of the device.\n        \"\"\"\n        v = await self._get_device_info(target, 'indoor_location', refresh)\n        return v['indoor_location']\n\n    async def get_device_battery(self, target, refresh: bool = False):\n\"\"\"Returns the battery of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n            refresh (bool, optional): whether you would like to refresh before retrieving the battery.\n             Defaults to False.\n\n        Returns:\n            int: the battery of the device.\n        \"\"\"\n        v = await self._get_device_info(target, 'battery', refresh)\n        return v['battery']\n\n    async def get_device_type(self, target):\n\"\"\"Returns the device type of a targeted device, i.e. gen 2, gen 3, etc.\n\n        Args:\n            target (str): the device or interaction URN.\n\n        Returns:\n            str: the device type.\n        \"\"\"\n        v = await self._get_device_info(target, 'type')\n        return v['type']\n\n    async def get_device_id(self, target):\n\"\"\"Returns the ID of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n\n        Returns:\n            str: the device ID.\n        \"\"\"\n        v = await self._get_device_info(target, 'id')\n        return v['id']\n\n    async def get_user_profile(self, target):\n\"\"\"Returns the user profile of a targeted device.\n\n        Args:\n            target (str): the device or interaction URN.\n\n        Returns:\n            str: the user profile registered to the device.\n        \"\"\"\n        v = await self._get_device_info(target, 'username')\n        return v['username']\n\n    async def get_device_location_enabled(self, target):\n\"\"\"Returns whether the location services on a device are enabled.\n\n        Args:\n            target (str): the device or interaction URN.\n\n        Returns:\n            str: 'true' if the device's location services are enabled, 'false' otherwise.\n        \"\"\"\n        v = await self._get_device_info(target, 'location_enabled')\n        return v['location_enabled']\n\n    # target can have only one item\n    async def _get_device_info(self, target, query, refresh: bool = False) -&gt; dict:\n\"\"\"Used privately by device information functions to retrieve varying information\n         on the device, such as the ID, location, battery, name and type.\n\n        Args:\n            target (str): the device or interaction URN.\n            query (str): which category of information you are retrieving.\n            refresh (bool): whether to refresh before retrieving information on the device.\n\n        Returns:\n            str: information on the device based on the query.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_get_device_info_request',\n            '_target': self.targets_from_source_uri(target),\n            'query': query,\n            'refresh': refresh\n        }\n        v = await self._send_receive(event)\n        return v\n\n    async def set_device_name(self, target, name: str):\n\"\"\"Sets the name of a targeted device and updates it on the Relay Dash.\n        The name remains updated until it is set again via a workflow or updated manually\n        on the Relay Dash.\n\n        Args:\n            target (str): the device or interaction URN.\n            name (str): a new name for your device.\n        \"\"\"\n        await self._set_device_info(target, 'label', name)\n\n    # set_device_channel is currently not supported\n    # async def set_device_channel(self, target, channel: str):\n    #     \"\"\"Sets the channel of a targeted device and updates it on the Relay Dash.\n    #     The new channel remains until it is set again via a workflow or updated on the\n    #     Relay Dash.\n    #\n    #     Args:\n    #         target (str): the device or interaction URN.\n    #         channel (str): the channel that you would like to update your device to.\n    #     \"\"\"\n    #     await self._set_device_info(target, 'channel', channel)\n\n    async def enable_location(self, target):\n\"\"\"Enables location services on a device.  Location services will remain\n        enabled until they are disabled on the Relay Dash or through a workflow.\n\n        Args:\n            target (str): the device or interaction URN.\n        \"\"\"\n        await self._set_device_info(target, 'location_enabled', 'true')\n\n    async def disable_location(self, target):\n\"\"\"Disables location services on a device.  Location services will remain\n        disabled until they are enabled on the Relay Dash or through a workflow.\n\n        Args:\n            target (str): the device or interaction URN.\n        \"\"\"\n        await self._set_device_info(target, 'location_enabled', 'false')\n\n    async def _set_device_info(self, target, field, value):\n\"\"\"Used privately by device information functions to set information\n        fields on the device, such as the location, name, and channel of\n        the device.\n\n        Args:\n            target (str): the device or interaction URN. This can only have one item.\n            field (str): the type of information you would like to set, such as the 'name', 'channel', etc.\n            value (str): the new value of the field.\n\n        Returns:\n            an event containing the updated device information.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_set_device_info_request',\n            '_target': self.targets_from_source_uri(target),\n            'field': field,\n            'value': value\n        }\n        await self._send_receive(event)\n        return event\n\n    # set_device_mode is currently not supported\n    # async def set_device_mode(self, target, mode:str='none'):\n    #     \"\"\"Sets the mode of the device.\n    #\n    #     Args:\n    #         target (str): the device or interaction URN.\n    #         mode (str, optional): the updated mode of the device, which can be 'panic', 'alarm', or 'none'.\n    #         Defaults to 'none'.\n    #     \"\"\"\n    #     event = {\n    #         '_type': 'wf_api_set_device_channel_request',\n    #         'target': target,\n    #         'mode': mode,\n    #     }\n    #     await self._send_receive(event)\n    #     # await self._set_device_info(target, )\n\n    @staticmethod\n    def led_info(rotations: int = None, count: int = None, duration: int = None, repeat_delay: int = None,\n                 pattern_repeats=None, colors=None):\n\"\"\"Sets information on a device, such as the number of rotations, count, duration, repeat delay,\n        pattern repeats, and colors.\n\n        Args:\n            rotations (int, optional): number of rotations. Defaults to None.\n            count (int, optional): the number of times the LEDs will perform an action. Defaults to None.\n            duration (int, optional): duration of the LED action in milliseconds. Defaults to None.\n            repeat_delay (int, optional): the length of delay in milliseconds. Defaults to None.\n            pattern_repeats (_type_, optional): the number of times a pattern should repeat. Defaults to None.\n            colors (_type_, optional): hex-code of the color for the LEDs. Defaults to None.\n\n        Returns:\n            information field that was set on the LEDs.\n        \"\"\"\n        info = {}\n        if rotations is not None:\n            info['rotations'] = rotations\n        if count is not None:\n            info['count'] = count\n        if duration is not None:\n            info['duration'] = duration\n        if repeat_delay is not None:\n            info['repeat_delay'] = repeat_delay\n        if pattern_repeats is not None:\n            info['pattern_repeats'] = pattern_repeats\n        if colors is not None:\n            info['colors'] = colors\n        return info\n\n    async def led_action(self, target, effect: str = 'flash', args=None):\n\"\"\"Private method used for performing actions on the LEDs, such as creating \n        a rainbow, flashing, rotating, etc.\n\n        Args:\n            target (str): the interaction URN.\n            effect (str, optional): effect to perform on LEDs, can be 'rainbow', 'rotate', 'flash', 'breath',\n                'static', or 'off'. Defaults to 'flash'.\n            args (optional): use led_info() to create args. Defaults to None.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_set_led_request',\n            '_target': self.targets_from_source_uri(target),\n            'effect': effect,\n            'args': args\n        }\n        await self._send_receive(event)\n\n    async def switch_all_led_on(self, target, color: str = '0000ff'):\n\"\"\"Switches all the LEDs on a device on to a specified color.\n\n        Args:\n            target (str): the interaction URN.\n            color (str, optional): the hex color code you would like the LEDs to be. Defaults to '0000ff'.\n        \"\"\"\n        await self.led_action(target, 'static', {'colors': {'ring': color}})\n\n    async def switch_led_on(self, target, index: int, color: str = '0000ff'):\n\"\"\"Switches on an LED at a particular index to a specified color.\n\n        Args:\n            target (str): the interaction URN.\n            index (int): the index of an LED, numbered 1-12.\n            color (str, optional): the hex color code you would like to turn the LED to. Defaults to '0000ff'.\n        \"\"\"\n        await self.led_action(target, 'static', {'colors': {index: color}})\n\n    async def rainbow(self, target, rotations: int = -1):\n\"\"\"Switches all the LEDs on to a configured rainbow pattern and rotates the rainbow\n        a specified number of times.\n\n        Args:\n            target (str): the interaction URN.\n            rotations (int, optional): the number of times you would like the rainbow to rotate. Defaults to -1,\n             meaning the rainbow will rotate indefinitely.\n        \"\"\"\n        await self.led_action(target, 'rainbow', {'rotations': rotations})\n\n    async def flash(self, target, color: str = '0000ff', count: int = -1):\n\"\"\"Switches all the LEDs on a device to a certain color and flashes them\n        a specified number of times.\n\n        Args:\n            target (str): the interaction URN.\n            color (str, optional): the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.\n            count (int, optional): the number of times you would like the LEDs to flash. Defaults to -1, meaning\n             the LEDs will flash indefinitely.\n        \"\"\"\n        await self.led_action(target, 'flash', {'colors': {'ring': color}, 'count': count})\n\n    async def breathe(self, target, color: str = '0000ff', count: int = -1):\n\"\"\"Switches all the LEDs on a device to a certain color and creates a 'breathing' effect,\n        where the LEDs will slowly light up a specified number of times.\n\n        Args:\n            target (str): the interaction URN.\n            color (str, optional): the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.\n            count (int, optional): the number of times you would like the LEDs to 'breathe'. Defaults to -1, meaning\n            the LEDs will 'breathe' indefinitely.\n        \"\"\"\n        await self.led_action(target, 'breathe', {'colors': {'ring': color}, 'count': count})\n\n    async def rotate(self, target, color: str = '0000ff', rotations: int = -1):\n\"\"\"Switches all the LEDs on a device to a certain color and rotates them a specified number\n        of times.\n\n        Args:\n            target (str): the interaction URN.\n            color (str, optional): the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.\n            rotations (int, optional): the number of times you would like the LEDs to rotate. Defaults to -1, meaning\n            the LEDs will rotate indefinitely.\n        \"\"\"\n        await self.led_action(target, 'rotate', {'colors': {'1': color}, 'rotations': rotations})\n\n    async def switch_all_led_off(self, target):\n\"\"\"Switches all the LEDs on a device off.\n\n        Args:\n            target (str): the interaction URN.\n        \"\"\"\n        await self.led_action(target, 'off', {})\n\n    async def vibrate(self, target, pattern: list = None):\n\"\"\"Makes the device vibrate in a particular pattern.  You can specify\n        how many vibrations you would like, the duration of each vibration in\n        milliseconds, and how long you would like the pauses between each vibration to last\n        in milliseconds.\n\n        Args:\n            target (str): the interaction URN.\n            pattern (list, optional): an array representing the pattern of your vibration. Defaults to None.\n        \"\"\"\n        if not pattern:\n            pattern = [100, 500, 500, 500, 500, 500]\n\n        event = {\n            '_type': 'wf_api_vibrate_request',\n            '_target': self.targets_from_source_uri(target),\n            'pattern': pattern\n        }\n        await self._send_receive(event)\n\n    async def start_timer(self, timeout: int = 60):\n\"\"\"Starts an unnamed timer, meaning this will be the only timer on your device.\n        The timer will fire when it reaches the value of the 'timeout' parameter.\n\n        Args:\n            timeout (int): the number of seconds you would like to wait until the timer fires.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_start_timer_request',\n            'timeout': timeout\n        }\n        await self._send_receive(event)\n\n    async def stop_timer(self):\n\"\"\"Stops an unnamed timer.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_stop_timer_request'\n        }\n        await self._send_receive(event)\n\n    async def terminate(self):\n\"\"\"Terminates a workflow.  This method is usually called\n        after your workflow has completed, and you would like to end the\n        workflow by calling end_interaction(), where you can then terminate\n        the workflow.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_terminate_request'\n        }\n        # there is no response\n        await self._send(event)\n\n    async def create_incident(self, originator, itype: str):\n\"\"\"Creates an incident that will alert the Relay Dash.\n\n        Args:\n            originator (str): the device URN that triggered the incident.\n            itype (str): the type of incident that occurred.\n\n        Returns:\n            str: the incident ID.\n        \"\"\"\n        # TODO: what are the values for itype?\n        event = {\n            '_type': 'wf_api_create_incident_request',\n            'type': itype,\n            'originator_uri': originator\n        }\n        v = await self._send_receive(event)\n        return v['incident_id']\n\n    async def resolve_incident(self, incident_id: str, reason: str):\n\"\"\"Resolves an incident that was created.\n\n        Args:\n            incident_id (str): the ID of the incident you would like to resolve.\n            reason (str): the reason for resolving the incident.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_resolve_incident_request',\n            'incident_id': incident_id,\n            'reason': reason\n        }\n        await self._send_receive(event)\n\n    # restart/powering down device is currently not supported\n\n    # async def restart_device(self, target):\n    #     \"\"\"Restarts a device during a workflow, without having\n    #     to physically restart the device via holding down the '-' button.\n    #\n    #     Args:\n    #         target (str): the URN of the device you would like to restart.\n    #     \"\"\"\n\n    #     event = {\n    #         '_type': 'wf_api_device_power_off_request',\n    #         '_target': self.targets_from_source_uri(target),\n    #         'restart': True\n    #     }\n    #     await self._send_receive(event)\n\n    # async def power_down_device(self, target):\n    #     \"\"\"Powers down a device during a workflow, without\n    #     having to physically power down the device via holding down the '+' button.\n    #\n    #     Args:\n    #         target (str): the URN of the device that you would like to power down.\n    #     \"\"\"\n    #     event = {\n    #         '_type': 'wf_api_device_power_off_request',\n    #         '_target': self.targets_from_source_uri(target),\n    #         'restart': False\n    #     }\n    #     await self._send_receive(event)\n\n    async def stop_playback(self, target, pb_id: str = None):\n        event = None\n        if type(pb_id) == list:\n            event = {\n                '_type': 'wf_api_stop_playback_request',\n                '_target': self.targets_from_source_uri(target),\n                'ids': pb_id\n            }\n        elif type(pb_id) == str:\n            pb_id = [pb_id]\n            event = {\n                '_type': 'wf_api_stop_playback_request',\n                '_target': self.targets_from_source_uri(target),\n                'ids': pb_id\n            }\n        elif pb_id is None:\n            event = {\n                '_type': 'wf_api_stop_playback_request',\n                '_target': self.targets_from_source_uri(target)\n            }\n        await self._send_receive(event)\n\n    async def translate(self, text: str, from_lang: str = 'en-US', to_lang: str = 'es-ES'):\n\"\"\"Translates text from one language to another.\n\n        Args:\n            text (str): the text that you would like to translate.\n            from_lang (str): the language that you would like to translate from.\n            to_lang (str): the language that you would like to translate to.\n\n        Returns:\n            str: the translated text.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_translate_request',\n            'text': text,\n            'from_lang': from_lang,\n            'to_lang': to_lang\n        }\n        response = await self._send_receive(event)\n        return response['text']\n\n    # target can have only one item\n    async def place_call(self, target, callee_uri: str):\n\"\"\"Places a call to another device.\n\n        Args:\n            target (str): the device which will place the call.\n            callee_uri (str): the URN of the device you would like to call.\n\n        Returns:\n            the event response.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_call_request',\n            '_target': self.targets_from_source_uri(target),\n            'uri': callee_uri\n        }\n        response = await self._send_receive(event)\n        return response['call_id']\n\n    # target can have only one item\n    async def answer_call(self, target, call_id: str):\n\"\"\"Answers an incoming call on your device.\n\n        Args:\n            target (str): the device which will answer the call.\n            call_id (str): the ID of the call to answer.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_answer_request',\n            '_target': self.targets_from_source_uri(target),\n            'call_id': call_id\n        }\n        await self._send_receive(event)\n\n    # target can have only one item\n    async def hangup_call(self, target, call_id: str):\n\"\"\"Ends (hangs up) a call on a device.\n\n        Args:\n            target (str): the device which will do the hangup.\n            call_id (str): the call ID.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_hangup_request',\n            '_target': self.targets_from_source_uri(target),\n            'call_id': call_id\n        }\n        await self._send_receive(event)\n\n    async def get_group_members(self, group_uri: str):\n\"\"\"Returns the members of a particular group.\n\n        Args:\n            group_uri (str): the URN of the group that you would like to retrieve members from.\n\n        Returns:\n            str[]: a list of the members within the specified group.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_group_query_request',\n            'query': 'list_members',\n            'group_uri': group_uri\n        }\n        response = await self._send_receive(event)\n        return response['member_uris']\n\n    async def is_group_member(self, group_name_uri: str, potential_member_name_uri: str):\n\"\"\"Checks whether a device is a member of a particular group.\n\n        Args:\n            group_name_uri (str): the URN of a group.\n            potential_member_name_uri: the URN of the device name.\n\n        Returns:\n            str: 'true' if the device is a member of the specified group, 'false' otherwise.\n        \"\"\"\n        this_group_name = parse_group_name(group_name_uri)\n        this_device_name = parse_device_name(potential_member_name_uri)\n        this_group_uri = group_member(this_group_name, this_device_name)\n        event = {\n            '_type': 'wf_api_group_query_request',\n            'query': 'is_member',\n            'group_uri': this_group_uri\n        }\n        response = await self._send_receive(event)\n        return response['is_member']\n\n    # target can have only one item\n    async def set_user_profile(self, target: str, username: str, force: bool = False):\n\"\"\"Sets the profile of a user by updating the username.\n\n        Args:\n            target (str): the device URN whose profile you would like to update.\n            username (str): the updated username for the device.\n            force (bool, optional): whether you would like to force this update. Defaults to False.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_set_user_profile_request',\n            '_target': self.targets_from_source_uri(target),\n            'username': username,\n            'force': force\n        }\n        await self._send_receive(event)\n\n    # target can have only one item\n    async def get_unread_inbox_size(self, target):\n\"\"\"Retrieves the number of messages in a device's inbox.\n\n        Args:\n            target (str): the device or interaction URN whose inbox you would like to check.\n\n        Returns:\n            str: the number of messages in the specified device's inbox.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_inbox_count_request',\n            '_target': self.targets_from_source_uri(target)\n        }\n        response = await self._send_receive(event)\n        return response['count']\n\n    async def play_unread_inbox_messages(self, target):\n\"\"\"Play a targeted device's inbox messages.\n\n        Args:\n            target (str): the device or interaction URN whose inbox messages you would like to play.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_play_inbox_messages_request',\n            '_target': self.targets_from_source_uri(target)\n        }\n        await self._send_receive(event)\n\n    async def log_message(self, message: str, category: Optional[str] = 'default', target: Optional[str] = None,\n                          content_type: Optional[str] = 'text/plain'):\n\"\"\"Log an analytics event from a workflow with the specified content and\n        under a specified category. This does not log the device who\n        triggered the workflow that called this function.\n\n        Args:\n            message (str): a description for your analytical event.\n            category (str, optional): a category for your analytical event. Defaults to 'default'.\n            target (str, optional): URN of the device that triggered this function. Defaults to None.\n            content_type (str, optional): encoding of the message string. Defaults to 'text/plain'.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_log_analytics_event_request',\n            'content': message,\n            'content_type': content_type,\n            'category': category,\n            'device_uri': target\n        }\n        await self._send_receive(event)\n\n    async def log_user_message(self, message: str, target, category: str):\n\"\"\"Log an analytic event from a workflow with the specified content and\n        under a specified category.  This includes the device who triggered the workflow\n        that called this function.\n\n        Args:\n            message (str): a description for your analytical event.\n            target (str, optional): the URN of a the device that triggered this function. Defaults to None.\n            category (str): a category for your analytical event.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_log_analytics_event_request',\n            'content': message,\n            'content_type': 'text/plain',\n            'category': category,\n            'device_uri': target\n        }\n        await self._send_receive(event)\n\n    async def set_timer(self, name: str, timer_type: str = 'timeout', timeout: int = 60, timeout_type: str = 'secs'):\n\"\"\" Serves as a named timer that can be either interval or timeout.  Allows you to specify\n        the unit of time.\n\n        Args:\n            name (str): a name for your timer.\n            timer_type (str, optional): can be 'timeout' or 'interval'. Defaults to 'timeout'.\n            timeout (int): an integer representing when you would like your timer to fire.\n            timeout_type (str, optional): can be 'ms', 'secs', 'mins' or 'hrs'. Defaults to 'secs'.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_set_timer_request',\n            'type': timer_type,\n            'name': name,\n            'timeout': timeout,\n            'timeout_type': timeout_type\n        }\n        await self._send_receive(event)\n\n    async def clear_timer(self, name: str):\n\"\"\"Clears the specified timer.\n\n        Args:\n            name (str): the name of the timer that you would like to clear.\n        \"\"\"\n        event = {\n            '_type': 'wf_api_clear_timer_request',\n            'name': name\n        }\n        await self._send_receive(event)\n\n    async def sms(self, stype: str, text: str, uri: str):\n        event = {\n            '_type': 'wf_api_sms_request',\n            'type': stype,\n            'text': text,\n            'uri': uri\n        }\n        response = await self._send_receive(event)\n        return response['message_id']\n\n    async def enable_home_channel(self, target):\n        await self._set_home_channel_state(target, True)\n\n    async def disable_home_channel(self, target):\n        await self._set_home_channel_state(target, False)\n\n    async def _set_home_channel_state(self, target, enabled: bool = True):\n        event = {\n            '_type': 'wf_api_set_home_channel_state_request',\n            '_target': self.targets_from_source_uri(target),\n            'enabled': enabled\n        }\n        await self._send_receive(event)\n\n    # target can have only one item\n    async def register(self, target, uri: str, password: str, expires: int):\n        event = {\n            '_type': 'wf_api_register_request',\n            '_target': self.targets_from_source_uri(target),\n            'uri': uri,\n            'password': password,\n            'expires': expires\n        }\n        await self._send_receive(event)\n\n    # invalid_type and missing_type are just for internal testing of error handling\n\n    async def _invalid_type(self):\n        event = {\n            '_type': 'wf_api_mkinard_breakage',\n            'device_id': 'TheQuickBrownFoxJumpedOverTheLazyDog',\n            'call_id': 'you can\\'t catch me'\n        }\n        await self._send_receive(event)\n\n    async def _missing_type(self):\n        event = {\n            'device_id': 'NowIsTheTimeForAllGoodMenToComeToTheAidOfYourCountry',\n            'call_id': 'you can\\'t catch me'\n        }\n        await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.__init__","title":"<code>__init__(workflow)</code>","text":"<p>Initializes workflow fields.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>your workflow.</p> required Source code in <code>relay/workflow.py</code> <pre><code>def __init__(self, workflow: Workflow):\n\"\"\"Initializes workflow fields.\n\n    Args:\n        workflow (Workflow): your workflow.\n    \"\"\"\n    self.workflow = workflow\n    self.websocket = None\n    self.id_futures = {}  # {_id: future}\n    self.event_futures = {}\n    self.logger = None\n</code></pre>"},{"location":"#relay.workflow.Relay.alert","title":"<code>alert(target, originator, name, text, push_opts=None)</code>  <code>async</code>","text":"<p>Sends out an alert to the specified group of devices and the Relay Dash.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the group URN that you would like to send an alert to.</p> required <code>originator</code> <code>str</code> <p>the URN of the device that triggered the alert.</p> required <code>name</code> <code>str</code> <p>a name for your alert.</p> required <code>text</code> <code>str</code> <p>the text that you would like to be spoken to the group as your alert.</p> required <code>push_opts</code> <code>dict</code> <p>push options for if the alert is sent to the Relay app on a virtual device. Defaults to an empty value.</p> <code>None</code> Source code in <code>relay/workflow.py</code> <pre><code>async def alert(self, target, originator: str, name: str, text: str, push_opts: dict = None):\n\"\"\"Sends out an alert to the specified group of devices and the Relay Dash.\n\n    Args:\n        target(str): the group URN that you would like to send an alert to.\n        originator (str): the URN of the device that triggered the alert.\n        name (str): a name for your alert.\n        text (str): the text that you would like to be spoken to the group as your alert.\n        push_opts (dict, optional): push options for if the alert is sent to the Relay app on a virtual device.\n         Defaults to an empty value.\n    \"\"\"\n    if push_opts is None:\n        push_opts = {}\n    await self._send_notification(target, originator, 'alert', text, name, push_opts)\n</code></pre>"},{"location":"#relay.workflow.Relay.answer_call","title":"<code>answer_call(target, call_id)</code>  <code>async</code>","text":"<p>Answers an incoming call on your device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device which will answer the call.</p> required <code>call_id</code> <code>str</code> <p>the ID of the call to answer.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def answer_call(self, target, call_id: str):\n\"\"\"Answers an incoming call on your device.\n\n    Args:\n        target (str): the device which will answer the call.\n        call_id (str): the ID of the call to answer.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_answer_request',\n        '_target': self.targets_from_source_uri(target),\n        'call_id': call_id\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.breathe","title":"<code>breathe(target, color='0000ff', count=-1)</code>  <code>async</code>","text":"<p>Switches all the LEDs on a device to a certain color and creates a 'breathing' effect, where the LEDs will slowly light up a specified number of times.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>color</code> <code>str</code> <p>the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.</p> <code>'0000ff'</code> <code>count</code> <code>int</code> <p>the number of times you would like the LEDs to 'breathe'. Defaults to -1, meaning</p> <code>-1</code> Source code in <code>relay/workflow.py</code> <pre><code>async def breathe(self, target, color: str = '0000ff', count: int = -1):\n\"\"\"Switches all the LEDs on a device to a certain color and creates a 'breathing' effect,\n    where the LEDs will slowly light up a specified number of times.\n\n    Args:\n        target (str): the interaction URN.\n        color (str, optional): the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.\n        count (int, optional): the number of times you would like the LEDs to 'breathe'. Defaults to -1, meaning\n        the LEDs will 'breathe' indefinitely.\n    \"\"\"\n    await self.led_action(target, 'breathe', {'colors': {'ring': color}, 'count': count})\n</code></pre>"},{"location":"#relay.workflow.Relay.broadcast","title":"<code>broadcast(target, originator, name, text, push_opts=None)</code>  <code>async</code>","text":"<p>Sends out a broadcast message to a group of devices.  The message is played out on all devices, as well as sent to the Relay Dash.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the group URN that you would like to broadcast your message to.</p> required <code>originator</code> <code>str</code> <p>the device URN that triggered the broadcast.</p> required <code>name</code> <code>str</code> <p>a name for your broadcast.</p> required <code>text</code> <code>str</code> <p>the text that you would like to be broadcasted to your group.</p> required <code>push_opts</code> <code>dict</code> <p>push options for if the broadcast is sent to the Relay app on a virtual device. Defaults to an empty value.</p> <code>None</code> Source code in <code>relay/workflow.py</code> <pre><code>async def broadcast(self, target, originator: str, name: str, text: str, push_opts: dict = None):\n\"\"\"Sends out a broadcast message to a group of devices.  The message is played out on\n    all devices, as well as sent to the Relay Dash.\n\n    Args:\n        target(str): the group URN that you would like to broadcast your message to.\n        originator (str): the device URN that triggered the broadcast.\n        name (str): a name for your broadcast.\n        text (str): the text that you would like to be broadcasted to your group.\n        push_opts (dict, optional): push options for if the broadcast is sent to the Relay app on a virtual\n         device. Defaults to an empty value.\n    \"\"\"\n    if push_opts is None:\n        push_opts = {}\n    await self._send_notification(target, originator, 'broadcast', text, name, push_opts)\n</code></pre>"},{"location":"#relay.workflow.Relay.cancel_alert","title":"<code>cancel_alert(target, name)</code>  <code>async</code>","text":"<p>Cancels an alert that was sent to a group of devices.  Particularly useful if you would like to cancel  the alert on all devices after one device has acknowledged the alert.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the device URN that has acknowledged the alert.</p> required <code>name</code> <code>str</code> <p>the name of the alert.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def cancel_alert(self, target, name: str):\n\"\"\"Cancels an alert that was sent to a group of devices.  Particularly useful if you would like to cancel\n     the alert on all devices after one device has acknowledged the alert.\n\n    Args:\n        target(str): the device URN that has acknowledged the alert.\n        name (str): the name of the alert.\n    \"\"\"\n    await self._send_notification(target, None, 'cancel', None, name)\n</code></pre>"},{"location":"#relay.workflow.Relay.cancel_broadcast","title":"<code>cancel_broadcast(target, name)</code>  <code>async</code>","text":"<p>Cancels the broadcast that was sent to a group of devices.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the device URN that is cancelling the broadcast.</p> required <code>name</code> <code>str</code> <p>the name of the broadcast that you would like to cancel.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def cancel_broadcast(self, target, name: str):\n\"\"\"Cancels the broadcast that was sent to a group of devices.\n\n    Args:\n        target(str): the device URN that is cancelling the broadcast.\n        name (str): the name of the broadcast that you would like to cancel.\n    \"\"\"\n    await self._send_notification(target, None, 'cancel', None, name)\n</code></pre>"},{"location":"#relay.workflow.Relay.clear_timer","title":"<code>clear_timer(name)</code>  <code>async</code>","text":"<p>Clears the specified timer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the timer that you would like to clear.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def clear_timer(self, name: str):\n\"\"\"Clears the specified timer.\n\n    Args:\n        name (str): the name of the timer that you would like to clear.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_clear_timer_request',\n        'name': name\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.create_incident","title":"<code>create_incident(originator, itype)</code>  <code>async</code>","text":"<p>Creates an incident that will alert the Relay Dash.</p> <p>Parameters:</p> Name Type Description Default <code>originator</code> <code>str</code> <p>the device URN that triggered the incident.</p> required <code>itype</code> <code>str</code> <p>the type of incident that occurred.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the incident ID.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def create_incident(self, originator, itype: str):\n\"\"\"Creates an incident that will alert the Relay Dash.\n\n    Args:\n        originator (str): the device URN that triggered the incident.\n        itype (str): the type of incident that occurred.\n\n    Returns:\n        str: the incident ID.\n    \"\"\"\n    # TODO: what are the values for itype?\n    event = {\n        '_type': 'wf_api_create_incident_request',\n        'type': itype,\n        'originator_uri': originator\n    }\n    v = await self._send_receive(event)\n    return v['incident_id']\n</code></pre>"},{"location":"#relay.workflow.Relay.disable_location","title":"<code>disable_location(target)</code>  <code>async</code>","text":"<p>Disables location services on a device.  Location services will remain disabled until they are enabled on the Relay Dash or through a workflow.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def disable_location(self, target):\n\"\"\"Disables location services on a device.  Location services will remain\n    disabled until they are enabled on the Relay Dash or through a workflow.\n\n    Args:\n        target (str): the device or interaction URN.\n    \"\"\"\n    await self._set_device_info(target, 'location_enabled', 'false')\n</code></pre>"},{"location":"#relay.workflow.Relay.enable_location","title":"<code>enable_location(target)</code>  <code>async</code>","text":"<p>Enables location services on a device.  Location services will remain enabled until they are disabled on the Relay Dash or through a workflow.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def enable_location(self, target):\n\"\"\"Enables location services on a device.  Location services will remain\n    enabled until they are disabled on the Relay Dash or through a workflow.\n\n    Args:\n        target (str): the device or interaction URN.\n    \"\"\"\n    await self._set_device_info(target, 'location_enabled', 'true')\n</code></pre>"},{"location":"#relay.workflow.Relay.end_interaction","title":"<code>end_interaction(target)</code>  <code>async</code>","text":"<p>Ends an interaction with the user.  Triggers an INTERACTION_ENDED event to signify that the user is done interacting with the device.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the interaction that you would like to end.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def end_interaction(self, target):\n\"\"\"Ends an interaction with the user.  Triggers an INTERACTION_ENDED event to signify\n    that the user is done interacting with the device.\n\n    Args:\n        target(str): the interaction that you would like to end.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_end_interaction_request',\n        '_target': self.targets_from_source_uri(target)\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.flash","title":"<code>flash(target, color='0000ff', count=-1)</code>  <code>async</code>","text":"<p>Switches all the LEDs on a device to a certain color and flashes them a specified number of times.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>color</code> <code>str</code> <p>the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.</p> <code>'0000ff'</code> <code>count</code> <code>int</code> <p>the number of times you would like the LEDs to flash. Defaults to -1, meaning the LEDs will flash indefinitely.</p> <code>-1</code> Source code in <code>relay/workflow.py</code> <pre><code>async def flash(self, target, color: str = '0000ff', count: int = -1):\n\"\"\"Switches all the LEDs on a device to a certain color and flashes them\n    a specified number of times.\n\n    Args:\n        target (str): the interaction URN.\n        color (str, optional): the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.\n        count (int, optional): the number of times you would like the LEDs to flash. Defaults to -1, meaning\n         the LEDs will flash indefinitely.\n    \"\"\"\n    await self.led_action(target, 'flash', {'colors': {'ring': color}, 'count': count})\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_address","title":"<code>get_device_address(target, refresh=False)</code>  <code>async</code>","text":"<p>Returns the address of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>refresh</code> <code>bool</code> <p>whether you would like to refresh before retrieving the address. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>the address of the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_address(self, target, refresh: bool = False):\n\"\"\"Returns the address of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n        refresh (bool, optional): whether you would like to refresh before retrieving the address.\n         Defaults to False.\n\n    Returns:\n        str: the address of the device.\n    \"\"\"\n    return await self.get_device_location(target, refresh)\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_battery","title":"<code>get_device_battery(target, refresh=False)</code>  <code>async</code>","text":"<p>Returns the battery of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>refresh</code> <code>bool</code> <p>whether you would like to refresh before retrieving the battery. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <p>the battery of the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_battery(self, target, refresh: bool = False):\n\"\"\"Returns the battery of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n        refresh (bool, optional): whether you would like to refresh before retrieving the battery.\n         Defaults to False.\n\n    Returns:\n        int: the battery of the device.\n    \"\"\"\n    v = await self._get_device_info(target, 'battery', refresh)\n    return v['battery']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_coordinates","title":"<code>get_device_coordinates(target, refresh=False)</code>  <code>async</code>","text":"<p>Retrieves the coordinates of the device's location.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>refresh</code> <code>bool</code> <p>whether you would like to refresh before retreiving the coordinates. Defaults to False.</p> <code>False</code> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_coordinates(self, target, refresh: bool = False):\n\"\"\"Retrieves the coordinates of the device's location.\n\n    Args:\n        target (str): the device or interaction URN.\n        refresh (bool, optional): whether you would like to refresh before retreiving the coordinates.\n         Defaults to False.\n    \"\"\"\n    v = await self._get_device_info(target, 'latlong', refresh)\n    return v['latlong']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_id","title":"<code>get_device_id(target)</code>  <code>async</code>","text":"<p>Returns the ID of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the device ID.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_id(self, target):\n\"\"\"Returns the ID of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n\n    Returns:\n        str: the device ID.\n    \"\"\"\n    v = await self._get_device_info(target, 'id')\n    return v['id']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_indoor_location","title":"<code>get_device_indoor_location(target, refresh=False)</code>  <code>async</code>","text":"<p>Returns the indoor location of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>refresh</code> <code>bool</code> <p>whether you would like to refresh before retrieving the location. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>the indoor location of the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_indoor_location(self, target, refresh: bool = False):\n\"\"\"Returns the indoor location of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n        refresh (bool, optional): whether you would like to refresh before retrieving the location.\n         Defaults to False.\n\n    Returns:\n        str: the indoor location of the device.\n    \"\"\"\n    v = await self._get_device_info(target, 'indoor_location', refresh)\n    return v['indoor_location']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_latlong","title":"<code>get_device_latlong(target, refresh=False)</code>  <code>async</code>","text":"<p>Returns the latitude and longitude coordinates of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>refresh</code> <code>bool</code> <p>whether you would like to refresh before retrieving the coordinates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>float[]: an array containing the latitude and longitude of the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_latlong(self, target, refresh: bool = False):\n\"\"\"Returns the latitude and longitude coordinates of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n        refresh (bool, optional): whether you would like to refresh before retrieving the coordinates.\n         Defaults to False.\n\n    Returns:\n        float[]: an array containing the latitude and longitude of the device.\n    \"\"\"\n    return await self.get_device_coordinates(target, refresh)\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_location","title":"<code>get_device_location(target, refresh=False)</code>  <code>async</code>","text":"<p>Returns the location of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>refresh</code> <code>bool</code> <p>whether you would like to refresh before retrieving the location. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>the location of the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_location(self, target, refresh: bool = False):\n\"\"\"Returns the location of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n        refresh (bool, optional): whether you would like to refresh before retrieving the location.\n         Defaults to False.\n\n    Returns:\n        str: the location of the device.\n    \"\"\"\n    v = await self._get_device_info(target, 'address', refresh)\n    return v['address']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_location_enabled","title":"<code>get_device_location_enabled(target)</code>  <code>async</code>","text":"<p>Returns whether the location services on a device are enabled.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>'true' if the device's location services are enabled, 'false' otherwise.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_location_enabled(self, target):\n\"\"\"Returns whether the location services on a device are enabled.\n\n    Args:\n        target (str): the device or interaction URN.\n\n    Returns:\n        str: 'true' if the device's location services are enabled, 'false' otherwise.\n    \"\"\"\n    v = await self._get_device_info(target, 'location_enabled')\n    return v['location_enabled']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_name","title":"<code>get_device_name(target)</code>  <code>async</code>","text":"<p>Returns the name of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the name of the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_name(self, target):\n\"\"\"Returns the name of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n\n    Returns:\n        str: the name of the device.\n    \"\"\"\n    v = await self._get_device_info(target, 'name')\n    return v['name']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_device_type","title":"<code>get_device_type(target)</code>  <code>async</code>","text":"<p>Returns the device type of a targeted device, i.e. gen 2, gen 3, etc.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the device type.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_device_type(self, target):\n\"\"\"Returns the device type of a targeted device, i.e. gen 2, gen 3, etc.\n\n    Args:\n        target (str): the device or interaction URN.\n\n    Returns:\n        str: the device type.\n    \"\"\"\n    v = await self._get_device_info(target, 'type')\n    return v['type']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_group_members","title":"<code>get_group_members(group_uri)</code>  <code>async</code>","text":"<p>Returns the members of a particular group.</p> <p>Parameters:</p> Name Type Description Default <code>group_uri</code> <code>str</code> <p>the URN of the group that you would like to retrieve members from.</p> required <p>Returns:</p> Type Description <p>str[]: a list of the members within the specified group.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_group_members(self, group_uri: str):\n\"\"\"Returns the members of a particular group.\n\n    Args:\n        group_uri (str): the URN of the group that you would like to retrieve members from.\n\n    Returns:\n        str[]: a list of the members within the specified group.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_group_query_request',\n        'query': 'list_members',\n        'group_uri': group_uri\n    }\n    response = await self._send_receive(event)\n    return response['member_uris']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_number_var","title":"<code>get_number_var(name, default=None)</code>  <code>async</code>","text":"<p>Retrieves a variable that was set either during workflow registration or through the set_var() function of type integer.  The variable can be retrieved anywhere within the workflow, but is erased after the workflow terminates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the variable to be retrieved.</p> required <code>default</code> <code>optional</code> <p>default value of the variable if it does not exist. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>the variable requested.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_number_var(self, name: str, default=None):\n\"\"\"Retrieves a variable that was set either during workflow registration\n    or through the set_var() function of type integer.  The variable can be retrieved anywhere\n    within the workflow, but is erased after the workflow terminates.\n\n    Args:\n        name (str): name of the variable to be retrieved.\n        default (optional): default value of the variable if it does not exist. Defaults to None.\n\n    Returns:\n        the variable requested.\n    \"\"\"\n    return int(await self.get_var(name, default))\n</code></pre>"},{"location":"#relay.workflow.Relay.get_source_uri_from_trigger","title":"<code>get_source_uri_from_trigger(trigger)</code>  <code>staticmethod</code>","text":"<p>Get the source URN from a workflow trigger</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>dict</code> <p>workflow trigger.</p> required <p>Raises:</p> Type Description <code>WorkflowException</code> <p>thrown if the trigger param is not a dictionary.</p> <code>WorkflowException</code> <p>thrown if the trigger param is not a trigger dictionary.</p> <code>WorkflowException</code> <p>thrown if there is no source_uri definition in the trigger.</p> <p>Returns:</p> Type Description <code>str</code> <p>the source URN as a string from the trigger.</p> Source code in <code>relay/workflow.py</code> <pre><code>@staticmethod\ndef get_source_uri_from_trigger(trigger: dict) -&gt; str:\n\"\"\"Get the source URN from a workflow trigger\n\n    Args:\n        trigger (dict): workflow trigger.\n\n    Raises:\n        WorkflowException: thrown if the trigger param is not a dictionary.\n        WorkflowException: thrown if the trigger param is not a trigger dictionary.\n        WorkflowException: thrown if there is no source_uri definition in the trigger.\n\n    Returns:\n        the source URN as a string from the trigger.\n\n    \"\"\"\n    Relay._validate_trigger(trigger)\n    source_uri = trigger['args']['source_uri']\n    return source_uri\n</code></pre>"},{"location":"#relay.workflow.Relay.get_unread_inbox_size","title":"<code>get_unread_inbox_size(target)</code>  <code>async</code>","text":"<p>Retrieves the number of messages in a device's inbox.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN whose inbox you would like to check.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the number of messages in the specified device's inbox.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_unread_inbox_size(self, target):\n\"\"\"Retrieves the number of messages in a device's inbox.\n\n    Args:\n        target (str): the device or interaction URN whose inbox you would like to check.\n\n    Returns:\n        str: the number of messages in the specified device's inbox.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_inbox_count_request',\n        '_target': self.targets_from_source_uri(target)\n    }\n    response = await self._send_receive(event)\n    return response['count']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_user_profile","title":"<code>get_user_profile(target)</code>  <code>async</code>","text":"<p>Returns the user profile of a targeted device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the user profile registered to the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_user_profile(self, target):\n\"\"\"Returns the user profile of a targeted device.\n\n    Args:\n        target (str): the device or interaction URN.\n\n    Returns:\n        str: the user profile registered to the device.\n    \"\"\"\n    v = await self._get_device_info(target, 'username')\n    return v['username']\n</code></pre>"},{"location":"#relay.workflow.Relay.get_var","title":"<code>get_var(name, default=None)</code>  <code>async</code>","text":"<p>Retrieves a variable that was set either during workflow registration or through the set_var() function.  The variable can be retrieved anywhere within the workflow, but is erased after the workflow terminates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the variable to be retrieved.</p> required <code>default</code> <code>optional</code> <p>default value of the variable if it does not exist. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>the variable requested.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def get_var(self, name: str, default=None):\n\"\"\"Retrieves a variable that was set either during workflow registration\n    or through the set_var() function.  The variable can be retrieved anywhere\n    within the workflow, but is erased after the workflow terminates.\n\n    Args:\n        name (str): name of the variable to be retrieved.\n        default (optional): default value of the variable if it does not exist. Defaults to None.\n\n    Returns:\n        the variable requested.\n    \"\"\"\n    # TODO: look in self.workflow.state to see all of what is available\n    event = {\n        '_type': 'wf_api_get_var_request',\n        'name': name\n    }\n    v = await self._send_receive(event)\n    return v.get('value', default)\n</code></pre>"},{"location":"#relay.workflow.Relay.hangup_call","title":"<code>hangup_call(target, call_id)</code>  <code>async</code>","text":"<p>Ends (hangs up) a call on a device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device which will do the hangup.</p> required <code>call_id</code> <code>str</code> <p>the call ID.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def hangup_call(self, target, call_id: str):\n\"\"\"Ends (hangs up) a call on a device.\n\n    Args:\n        target (str): the device which will do the hangup.\n        call_id (str): the call ID.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_hangup_request',\n        '_target': self.targets_from_source_uri(target),\n        'call_id': call_id\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.interaction_options","title":"<code>interaction_options(color='0000ff', input_types=None, home_channel='suspend')</code>  <code>staticmethod</code>","text":"<p>Options for when an interaction is started via a workflow.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>desired color of LEDs when an interaction is started. Defaults to \"0000ff\".</p> <code>'0000ff'</code> <code>input_types</code> <code>list</code> <p>input types you would like for the interaction. Defaults to an empty list.</p> <code>None</code> <code>home_channel</code> <code>str</code> <p>home channel for the device during the interaction. Defaults to \"suspend\".</p> <code>'suspend'</code> <p>Returns:</p> Type Description <p>the options specified.</p> Source code in <code>relay/workflow.py</code> <pre><code>@staticmethod\ndef interaction_options(color: str = \"0000ff\", input_types: list = None, home_channel: str = \"suspend\"):\n\"\"\"Options for when an interaction is started via a workflow.\n\n    Args:\n        color (str, optional): desired color of LEDs when an interaction is started. Defaults to \"0000ff\".\n        input_types (list, optional): input types you would like for the interaction. Defaults to an empty list.\n        home_channel (str, optional): home channel for the device during the interaction. Defaults to \"suspend\".\n\n    Returns:\n        the options specified.\n    \"\"\"\n    if input_types is None:\n        input_types = []\n    options = {\n        'color': color,\n        'input_types': input_types,\n        'home_channel': home_channel\n    }\n    return options\n</code></pre>"},{"location":"#relay.workflow.Relay.is_group_member","title":"<code>is_group_member(group_name_uri, potential_member_name_uri)</code>  <code>async</code>","text":"<p>Checks whether a device is a member of a particular group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name_uri</code> <code>str</code> <p>the URN of a group.</p> required <code>potential_member_name_uri</code> <code>str</code> <p>the URN of the device name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>'true' if the device is a member of the specified group, 'false' otherwise.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def is_group_member(self, group_name_uri: str, potential_member_name_uri: str):\n\"\"\"Checks whether a device is a member of a particular group.\n\n    Args:\n        group_name_uri (str): the URN of a group.\n        potential_member_name_uri: the URN of the device name.\n\n    Returns:\n        str: 'true' if the device is a member of the specified group, 'false' otherwise.\n    \"\"\"\n    this_group_name = parse_group_name(group_name_uri)\n    this_device_name = parse_device_name(potential_member_name_uri)\n    this_group_uri = group_member(this_group_name, this_device_name)\n    event = {\n        '_type': 'wf_api_group_query_request',\n        'query': 'is_member',\n        'group_uri': this_group_uri\n    }\n    response = await self._send_receive(event)\n    return response['is_member']\n</code></pre>"},{"location":"#relay.workflow.Relay.led_action","title":"<code>led_action(target, effect='flash', args=None)</code>  <code>async</code>","text":"<p>Private method used for performing actions on the LEDs, such as creating  a rainbow, flashing, rotating, etc.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>effect</code> <code>str</code> <p>effect to perform on LEDs, can be 'rainbow', 'rotate', 'flash', 'breath', 'static', or 'off'. Defaults to 'flash'.</p> <code>'flash'</code> <code>args</code> <code>optional</code> <p>use led_info() to create args. Defaults to None.</p> <code>None</code> Source code in <code>relay/workflow.py</code> <pre><code>async def led_action(self, target, effect: str = 'flash', args=None):\n\"\"\"Private method used for performing actions on the LEDs, such as creating \n    a rainbow, flashing, rotating, etc.\n\n    Args:\n        target (str): the interaction URN.\n        effect (str, optional): effect to perform on LEDs, can be 'rainbow', 'rotate', 'flash', 'breath',\n            'static', or 'off'. Defaults to 'flash'.\n        args (optional): use led_info() to create args. Defaults to None.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_set_led_request',\n        '_target': self.targets_from_source_uri(target),\n        'effect': effect,\n        'args': args\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.led_info","title":"<code>led_info(rotations=None, count=None, duration=None, repeat_delay=None, pattern_repeats=None, colors=None)</code>  <code>staticmethod</code>","text":"<p>Sets information on a device, such as the number of rotations, count, duration, repeat delay, pattern repeats, and colors.</p> <p>Parameters:</p> Name Type Description Default <code>rotations</code> <code>int</code> <p>number of rotations. Defaults to None.</p> <code>None</code> <code>count</code> <code>int</code> <p>the number of times the LEDs will perform an action. Defaults to None.</p> <code>None</code> <code>duration</code> <code>int</code> <p>duration of the LED action in milliseconds. Defaults to None.</p> <code>None</code> <code>repeat_delay</code> <code>int</code> <p>the length of delay in milliseconds. Defaults to None.</p> <code>None</code> <code>pattern_repeats</code> <code>_type_</code> <p>the number of times a pattern should repeat. Defaults to None.</p> <code>None</code> <code>colors</code> <code>_type_</code> <p>hex-code of the color for the LEDs. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>information field that was set on the LEDs.</p> Source code in <code>relay/workflow.py</code> <pre><code>@staticmethod\ndef led_info(rotations: int = None, count: int = None, duration: int = None, repeat_delay: int = None,\n             pattern_repeats=None, colors=None):\n\"\"\"Sets information on a device, such as the number of rotations, count, duration, repeat delay,\n    pattern repeats, and colors.\n\n    Args:\n        rotations (int, optional): number of rotations. Defaults to None.\n        count (int, optional): the number of times the LEDs will perform an action. Defaults to None.\n        duration (int, optional): duration of the LED action in milliseconds. Defaults to None.\n        repeat_delay (int, optional): the length of delay in milliseconds. Defaults to None.\n        pattern_repeats (_type_, optional): the number of times a pattern should repeat. Defaults to None.\n        colors (_type_, optional): hex-code of the color for the LEDs. Defaults to None.\n\n    Returns:\n        information field that was set on the LEDs.\n    \"\"\"\n    info = {}\n    if rotations is not None:\n        info['rotations'] = rotations\n    if count is not None:\n        info['count'] = count\n    if duration is not None:\n        info['duration'] = duration\n    if repeat_delay is not None:\n        info['repeat_delay'] = repeat_delay\n    if pattern_repeats is not None:\n        info['pattern_repeats'] = pattern_repeats\n    if colors is not None:\n        info['colors'] = colors\n    return info\n</code></pre>"},{"location":"#relay.workflow.Relay.listen","title":"<code>listen(target, phrases=None, transcribe=True, alt_lang=None, timeout=60)</code>  <code>async</code>","text":"<p>Listens for the user to speak into the device.  Utilizes speech to text functionality to interact with the user.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>phrases</code> <code>string[]</code> <p>optional phrases that you would like to limit the user's response to. Defaults to None.</p> <code>None</code> <code>transcribe</code> <code>bool</code> <p>whether you would like to transcribe the user's reponse. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>timeout for how long the device will wait for user's response. Defaults to 60.</p> <code>60</code> <code>alt_lang</code> <code>str</code> <p>if you would like the device to listen for a response in a specific language. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>text representation of what the user had spoken into the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def listen(self, target, phrases=None, transcribe: bool = True, alt_lang: str = None, timeout: int = 60):\n\"\"\"Listens for the user to speak into the device.  Utilizes speech to text functionality to interact\n    with the user.\n\n    Args:\n        target (str): the interaction URN.\n        phrases (string[], optional): optional phrases that you would like to limit the user's response to.\n         Defaults to None.\n        transcribe (bool, optional): whether you would like to transcribe the user's reponse. Defaults to True.\n        timeout (int, optional): timeout for how long the device will wait for user's response. Defaults to 60.\n        alt_lang (str, optional): if you would like the device to listen for a response in a specific language.\n         Defaults to None.\n\n    Returns:\n        text representation of what the user had spoken into the device.\n    \"\"\"\n    if phrases is None:\n        phrases = []\n    if isinstance(phrases, str):\n        phrases = [phrases]\n\n    _id = uuid.uuid4().hex\n    event = {\n        '_type': 'wf_api_listen_request',\n        '_target': self.targets_from_source_uri(target),\n        'phrases': phrases,\n        'transcribe': transcribe,\n        'timeout': timeout,\n        'alt_lang': alt_lang\n    }\n\n    criteria = {\n        '_type': 'wf_api_speech_event',\n        'request_id': _id\n    }\n    # need to add this before _send_receive to avoid race condition\n    event_future = self._set_event_match(criteria)\n    await self._send_receive(event, _id)\n    speech_event = await self._wait_for_event_match(event_future, timeout)\n\n    if transcribe:\n        return speech_event['text']\n    else:\n        return speech_event['audio']\n</code></pre>"},{"location":"#relay.workflow.Relay.log_message","title":"<code>log_message(message, category='default', target=None, content_type='text/plain')</code>  <code>async</code>","text":"<p>Log an analytics event from a workflow with the specified content and under a specified category. This does not log the device who triggered the workflow that called this function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>a description for your analytical event.</p> required <code>category</code> <code>str</code> <p>a category for your analytical event. Defaults to 'default'.</p> <code>'default'</code> <code>target</code> <code>str</code> <p>URN of the device that triggered this function. Defaults to None.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>encoding of the message string. Defaults to 'text/plain'.</p> <code>'text/plain'</code> Source code in <code>relay/workflow.py</code> <pre><code>async def log_message(self, message: str, category: Optional[str] = 'default', target: Optional[str] = None,\n                      content_type: Optional[str] = 'text/plain'):\n\"\"\"Log an analytics event from a workflow with the specified content and\n    under a specified category. This does not log the device who\n    triggered the workflow that called this function.\n\n    Args:\n        message (str): a description for your analytical event.\n        category (str, optional): a category for your analytical event. Defaults to 'default'.\n        target (str, optional): URN of the device that triggered this function. Defaults to None.\n        content_type (str, optional): encoding of the message string. Defaults to 'text/plain'.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_log_analytics_event_request',\n        'content': message,\n        'content_type': content_type,\n        'category': category,\n        'device_uri': target\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.log_user_message","title":"<code>log_user_message(message, target, category)</code>  <code>async</code>","text":"<p>Log an analytic event from a workflow with the specified content and under a specified category.  This includes the device who triggered the workflow that called this function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>a description for your analytical event.</p> required <code>target</code> <code>str</code> <p>the URN of a the device that triggered this function. Defaults to None.</p> required <code>category</code> <code>str</code> <p>a category for your analytical event.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def log_user_message(self, message: str, target, category: str):\n\"\"\"Log an analytic event from a workflow with the specified content and\n    under a specified category.  This includes the device who triggered the workflow\n    that called this function.\n\n    Args:\n        message (str): a description for your analytical event.\n        target (str, optional): the URN of a the device that triggered this function. Defaults to None.\n        category (str): a category for your analytical event.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_log_analytics_event_request',\n        'content': message,\n        'content_type': 'text/plain',\n        'category': category,\n        'device_uri': target\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.make_target_uris","title":"<code>make_target_uris(trigger)</code>  <code>staticmethod</code>","text":"<p>Creates a target URN after receiving a workflow trigger.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>dict</code> <p>workflow trigger.</p> required <p>Raises:</p> Type Description <code>WorkflowException</code> <p>thrown if the trigger param is not a dictionary.</p> <code>WorkflowException</code> <p>thrown if the trigger param is not a trigger dictionary.</p> <code>WorkflowException</code> <p>thrown if there is no source_uri definition in the trigger.</p> <p>Returns:</p> Type Description <p>a target object created from the trigger.</p> Source code in <code>relay/workflow.py</code> <pre><code>@staticmethod\ndef make_target_uris(trigger: dict):\n\"\"\"Creates a target URN after receiving a workflow trigger.\n\n    Args:\n        trigger (dict): workflow trigger.\n\n    Raises:\n        WorkflowException: thrown if the trigger param is not a dictionary.\n        WorkflowException: thrown if the trigger param is not a trigger dictionary.\n        WorkflowException: thrown if there is no source_uri definition in the trigger.\n\n    Returns:\n        a target object created from the trigger.\n    \"\"\"\n    Relay._validate_trigger(trigger)\n    target = {\n        'uris': [trigger['args']['source_uri']]\n    }\n    return target\n</code></pre>"},{"location":"#relay.workflow.Relay.place_call","title":"<code>place_call(target, callee_uri)</code>  <code>async</code>","text":"<p>Places a call to another device.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device which will place the call.</p> required <code>callee_uri</code> <code>str</code> <p>the URN of the device you would like to call.</p> required <p>Returns:</p> Type Description <p>the event response.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def place_call(self, target, callee_uri: str):\n\"\"\"Places a call to another device.\n\n    Args:\n        target (str): the device which will place the call.\n        callee_uri (str): the URN of the device you would like to call.\n\n    Returns:\n        the event response.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_call_request',\n        '_target': self.targets_from_source_uri(target),\n        'uri': callee_uri\n    }\n    response = await self._send_receive(event)\n    return response['call_id']\n</code></pre>"},{"location":"#relay.workflow.Relay.play","title":"<code>play(target, filename)</code>  <code>async</code>","text":"<p>Plays a custom audio file that was uploaded by the user.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the interaction URN.</p> required <code>filename</code> <code>str</code> <p>the name of the audio file.</p> required <p>Returns:</p> Type Description <p>the response id after the audio file has been played on the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def play(self, target, filename: str):\n\"\"\"Plays a custom audio file that was uploaded by the user.\n\n    Args:\n        target(str): the interaction URN.\n        filename (str): the name of the audio file.\n\n    Returns:\n        the response id after the audio file has been played on the device.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_play_request',\n        '_target': self.targets_from_source_uri(target),\n        'filename': filename\n    }\n    response = await self._send_receive(event)\n    return response['id']\n</code></pre>"},{"location":"#relay.workflow.Relay.play_and_wait","title":"<code>play_and_wait(target, filename)</code>  <code>async</code>","text":"<p>Plays a custom audio file that was uploaded by the user. Waits until the audio file has finished playing before continuing through the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the interaction URN.</p> required <code>filename</code> <code>str</code> <p>the name of the audio file.</p> required <p>Returns:</p> Type Description <p>the response id after the audio file has been played on the device.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def play_and_wait(self, target, filename: str):\n\"\"\"Plays a custom audio file that was uploaded by the user.\n    Waits until the audio file has finished playing before continuing through\n    the workflow.\n\n    Args:\n        target(str): the interaction URN.\n        filename (str): the name of the audio file.\n\n    Returns:\n        the response id after the audio file has been played on the device.\n    \"\"\"\n    _id = uuid.uuid4().hex\n    event = {\n        '_type': 'wf_api_play_request',\n        '_target': self.targets_from_source_uri(target),\n        'filename': filename\n    }\n\n    criteria = {\n        '_type': 'wf_api_prompt_event',\n        'type': 'stopped',\n        'id': _id\n    }\n\n    event_future = self._set_event_match(criteria)\n    response = await self._send_receive(event, _id)\n    await self._wait_for_event_match(event_future, 30)\n    return response['id']\n</code></pre>"},{"location":"#relay.workflow.Relay.play_unread_inbox_messages","title":"<code>play_unread_inbox_messages(target)</code>  <code>async</code>","text":"<p>Play a targeted device's inbox messages.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN whose inbox messages you would like to play.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def play_unread_inbox_messages(self, target):\n\"\"\"Play a targeted device's inbox messages.\n\n    Args:\n        target (str): the device or interaction URN whose inbox messages you would like to play.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_play_inbox_messages_request',\n        '_target': self.targets_from_source_uri(target)\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.push_options","title":"<code>push_options(priority='normal', title=None, body=None, sound='default')</code>  <code>staticmethod</code>","text":"<p>Push options for a virtual device after receiving a notification on the Relay App.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>str</code> <p>priority of the notification. Can be 'normal', 'high', or 'critical'. Defaults to 'normal'.</p> <code>'normal'</code> <code>title</code> <code>str</code> <p>title of the notification. Defaults to None.</p> <code>None</code> <code>body</code> <code>str</code> <p>body of the notification. Defaults to None.</p> <code>None</code> <code>sound</code> <code>str</code> <p>sound to be played when notification appears on app. Can be 'default', or 'sos'. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <p>the options for priority and sound as specified.</p> Source code in <code>relay/workflow.py</code> <pre><code>@staticmethod\ndef push_options(priority: str = 'normal', title: str = None, body: str = None, sound: str = 'default'):\n\"\"\"Push options for a virtual device after receiving a notification on the Relay App.\n\n    Args:\n        priority (str, optional): priority of the notification. Can be 'normal', 'high', or 'critical'.\n         Defaults to 'normal'.\n        title (str, optional): title of the notification. Defaults to None.\n        body (str, optional): body of the notification. Defaults to None.\n        sound (str, optional): sound to be played when notification appears on app. Can be 'default', or 'sos'.\n          Defaults to 'default'.\n\n    Returns:\n        the options for priority and sound as specified.\n    \"\"\"\n\n    options = {\n        'priority': priority,\n        'sound': sound\n    }\n    if title is not None:\n        options['title'] = title\n    if body is not None:\n        options['body'] = body\n    return options\n</code></pre>"},{"location":"#relay.workflow.Relay.rainbow","title":"<code>rainbow(target, rotations=-1)</code>  <code>async</code>","text":"<p>Switches all the LEDs on to a configured rainbow pattern and rotates the rainbow a specified number of times.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>rotations</code> <code>int</code> <p>the number of times you would like the rainbow to rotate. Defaults to -1, meaning the rainbow will rotate indefinitely.</p> <code>-1</code> Source code in <code>relay/workflow.py</code> <pre><code>async def rainbow(self, target, rotations: int = -1):\n\"\"\"Switches all the LEDs on to a configured rainbow pattern and rotates the rainbow\n    a specified number of times.\n\n    Args:\n        target (str): the interaction URN.\n        rotations (int, optional): the number of times you would like the rainbow to rotate. Defaults to -1,\n         meaning the rainbow will rotate indefinitely.\n    \"\"\"\n    await self.led_action(target, 'rainbow', {'rotations': rotations})\n</code></pre>"},{"location":"#relay.workflow.Relay.resolve_incident","title":"<code>resolve_incident(incident_id, reason)</code>  <code>async</code>","text":"<p>Resolves an incident that was created.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>the ID of the incident you would like to resolve.</p> required <code>reason</code> <code>str</code> <p>the reason for resolving the incident.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def resolve_incident(self, incident_id: str, reason: str):\n\"\"\"Resolves an incident that was created.\n\n    Args:\n        incident_id (str): the ID of the incident you would like to resolve.\n        reason (str): the reason for resolving the incident.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_resolve_incident_request',\n        'incident_id': incident_id,\n        'reason': reason\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.rotate","title":"<code>rotate(target, color='0000ff', rotations=-1)</code>  <code>async</code>","text":"<p>Switches all the LEDs on a device to a certain color and rotates them a specified number of times.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>color</code> <code>str</code> <p>the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.</p> <code>'0000ff'</code> <code>rotations</code> <code>int</code> <p>the number of times you would like the LEDs to rotate. Defaults to -1, meaning</p> <code>-1</code> Source code in <code>relay/workflow.py</code> <pre><code>async def rotate(self, target, color: str = '0000ff', rotations: int = -1):\n\"\"\"Switches all the LEDs on a device to a certain color and rotates them a specified number\n    of times.\n\n    Args:\n        target (str): the interaction URN.\n        color (str, optional): the hex color code you would like to turn the LEDs to. Defaults to '0000ff'.\n        rotations (int, optional): the number of times you would like the LEDs to rotate. Defaults to -1, meaning\n        the LEDs will rotate indefinitely.\n    \"\"\"\n    await self.led_action(target, 'rotate', {'colors': {'1': color}, 'rotations': rotations})\n</code></pre>"},{"location":"#relay.workflow.Relay.say","title":"<code>say(target, text, lang='en-US')</code>  <code>async</code>","text":"<p>Utilizes text to speech capabilities to make the device 'speak' to the user.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the interaction URN.</p> required <code>text</code> <code>str</code> <p>what you would like the device to say.</p> required <code>lang</code> <code>str</code> <p>the language of the text that is being spoken. Defaults to 'en-US'.</p> <code>'en-US'</code> <p>Returns:</p> Type Description <p>the response ID after the device speaks to the user.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def say(self, target, text: str, lang: str = 'en-US'):\n\"\"\"Utilizes text to speech capabilities to make the device 'speak' to the user.\n\n    Args:\n        target(str): the interaction URN.\n        text (str): what you would like the device to say.\n        lang (str, optional): the language of the text that is being spoken. Defaults to 'en-US'.\n\n    Returns:\n        the response ID after the device speaks to the user.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_say_request',\n        '_target': self.targets_from_source_uri(target),\n        'text': text,\n        'lang': lang\n    }\n    response = await self._send_receive(event)\n    return response['id']\n</code></pre>"},{"location":"#relay.workflow.Relay.say_and_wait","title":"<code>say_and_wait(target, text, lang='en-US')</code>  <code>async</code>","text":"<p>Utilizes text to speech capabilities to make the device 'speak' to the user. Waits until the text is fully played out on the device before continuing.</p> <p>Parameters:</p> Name Type Description Default <code>target(str)</code> <p>the interaction URN.</p> required <code>text</code> <code>str</code> <p>what you would like the device to say.</p> required <code>lang</code> <code>str</code> <p>the language of the text that is being spoken. Defaults to 'en-US'.</p> <code>'en-US'</code> <p>Returns:</p> Type Description <p>the response ID after the device speaks to the user.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def say_and_wait(self, target, text: str, lang: str = 'en-US'):\n\"\"\"Utilizes text to speech capabilities to make the device 'speak' to the user.\n    Waits until the text is fully played out on the device before continuing.\n\n    Args:\n        target(str): the interaction URN.\n        text (str): what you would like the device to say.\n        lang (str, optional): the language of the text that is being spoken. Defaults to 'en-US'.\n\n    Returns:\n        the response ID after the device speaks to the user.\n    \"\"\"\n    _id = uuid.uuid4().hex\n    event = {\n        '_type': 'wf_api_say_request',\n        '_target': self.targets_from_source_uri(target),\n        'text': text,\n        'lang': lang\n    }\n\n    criteria = {\n        '_type': 'wf_api_prompt_event',\n        'type': 'stopped',\n        'id': _id}\n\n    event_future = self._set_event_match(criteria)\n    response = await self._send_receive(event, _id)\n    await self._wait_for_event_match(event_future, 30)\n    logger.debug(f'wait complete for {target}')\n    return response['id']\n</code></pre>"},{"location":"#relay.workflow.Relay.set_channel","title":"<code>set_channel(target, channel_name, suppress_tts=False, disable_home_channel=False)</code>  <code>async</code>","text":"<p>Sets the channel that a device is on.  This can be used to change the channel of a device during a workflow, where the channel will also be updated on the Relay Dash.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>channel_name</code> <code>str</code> <p>the name of the channel you would like to set your device to.</p> required <code>suppress_tts</code> <code>bool</code> <p>whether you would like to surpress text to speech. Defaults to False.</p> <code>False</code> <code>disable_home_channel</code> <code>bool</code> <p>whether you would like to disable the home channel. Defaults to False.</p> <code>False</code> Source code in <code>relay/workflow.py</code> <pre><code>async def set_channel(self, target, channel_name: str, suppress_tts: bool = False,\n                      disable_home_channel: bool = False):\n\"\"\"Sets the channel that a device is on.  This can be used to change the channel of a device during a workflow,\n    where the channel will also be updated on the Relay Dash.\n\n    Args:\n        target (str): the device or interaction URN.\n        channel_name (str): the name of the channel you would like to set your device to.\n        suppress_tts (bool, optional): whether you would like to surpress text to speech. Defaults to False.\n        disable_home_channel (bool, optional): whether you would like to disable the home channel.\n         Defaults to False.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_set_channel_request',\n        '_target': self.targets_from_source_uri(target),\n        'channel_name': channel_name,\n        'suppress_tts': suppress_tts,\n        'disable_home_channel': disable_home_channel\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.set_device_name","title":"<code>set_device_name(target, name)</code>  <code>async</code>","text":"<p>Sets the name of a targeted device and updates it on the Relay Dash. The name remains updated until it is set again via a workflow or updated manually on the Relay Dash.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device or interaction URN.</p> required <code>name</code> <code>str</code> <p>a new name for your device.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def set_device_name(self, target, name: str):\n\"\"\"Sets the name of a targeted device and updates it on the Relay Dash.\n    The name remains updated until it is set again via a workflow or updated manually\n    on the Relay Dash.\n\n    Args:\n        target (str): the device or interaction URN.\n        name (str): a new name for your device.\n    \"\"\"\n    await self._set_device_info(target, 'label', name)\n</code></pre>"},{"location":"#relay.workflow.Relay.set_timer","title":"<code>set_timer(name, timer_type='timeout', timeout=60, timeout_type='secs')</code>  <code>async</code>","text":"<p>Serves as a named timer that can be either interval or timeout.  Allows you to specify the unit of time.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a name for your timer.</p> required <code>timer_type</code> <code>str</code> <p>can be 'timeout' or 'interval'. Defaults to 'timeout'.</p> <code>'timeout'</code> <code>timeout</code> <code>int</code> <p>an integer representing when you would like your timer to fire.</p> <code>60</code> <code>timeout_type</code> <code>str</code> <p>can be 'ms', 'secs', 'mins' or 'hrs'. Defaults to 'secs'.</p> <code>'secs'</code> Source code in <code>relay/workflow.py</code> <pre><code>async def set_timer(self, name: str, timer_type: str = 'timeout', timeout: int = 60, timeout_type: str = 'secs'):\n\"\"\" Serves as a named timer that can be either interval or timeout.  Allows you to specify\n    the unit of time.\n\n    Args:\n        name (str): a name for your timer.\n        timer_type (str, optional): can be 'timeout' or 'interval'. Defaults to 'timeout'.\n        timeout (int): an integer representing when you would like your timer to fire.\n        timeout_type (str, optional): can be 'ms', 'secs', 'mins' or 'hrs'. Defaults to 'secs'.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_set_timer_request',\n        'type': timer_type,\n        'name': name,\n        'timeout': timeout,\n        'timeout_type': timeout_type\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.set_user_profile","title":"<code>set_user_profile(target, username, force=False)</code>  <code>async</code>","text":"<p>Sets the profile of a user by updating the username.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the device URN whose profile you would like to update.</p> required <code>username</code> <code>str</code> <p>the updated username for the device.</p> required <code>force</code> <code>bool</code> <p>whether you would like to force this update. Defaults to False.</p> <code>False</code> Source code in <code>relay/workflow.py</code> <pre><code>async def set_user_profile(self, target: str, username: str, force: bool = False):\n\"\"\"Sets the profile of a user by updating the username.\n\n    Args:\n        target (str): the device URN whose profile you would like to update.\n        username (str): the updated username for the device.\n        force (bool, optional): whether you would like to force this update. Defaults to False.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_set_user_profile_request',\n        '_target': self.targets_from_source_uri(target),\n        'username': username,\n        'force': force\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.set_var","title":"<code>set_var(name, value)</code>  <code>async</code>","text":"<p>Sets a variable with the corresponding name and value. Scope of the variable is from start to end of a workflow.  Note that you  can only set values of type string. Args:     name (str): name of the variable to be created.     value (str): value that the variable will hold.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def set_var(self, name: str, value: str):\n\"\"\"Sets a variable with the corresponding name and value. Scope of\n    the variable is from start to end of a workflow.  Note that you \n    can only set values of type string.\n    Args:\n        name (str): name of the variable to be created.\n        value (str): value that the variable will hold.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_set_var_request',\n        'name': name,\n        'value': value\n    }\n    response = await self._send_receive(event)\n    return response['value']\n</code></pre>"},{"location":"#relay.workflow.Relay.start_interaction","title":"<code>start_interaction(target, name, options=None)</code>  <code>async</code>","text":"<p>Starts an interaction with the user.  Triggers an INTERACTION_STARTED event and allows the user to interact with the device via functions that require an  interaction URN.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>target</code> <p>the device that you would like to start an interaction with.</p> required <code>name</code> <code>str</code> <p>a name for your interaction.</p> required <code>options</code> <code>optional</code> <p>can be color, home channel, or input types. Defaults to None.</p> <code>None</code> Source code in <code>relay/workflow.py</code> <pre><code>async def start_interaction(self, target, name: str, options=None):\n\"\"\"Starts an interaction with the user.  Triggers an INTERACTION_STARTED event\n    and allows the user to interact with the device via functions that require an \n    interaction URN.\n\n    Args:\n        target (target): the device that you would like to start an interaction with.\n        name (str): a name for your interaction.\n        options (optional): can be color, home channel, or input types. Defaults to None.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_start_interaction_request',\n        '_target': target,\n        'name': name,\n        'options': options\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.start_timer","title":"<code>start_timer(timeout=60)</code>  <code>async</code>","text":"<p>Starts an unnamed timer, meaning this will be the only timer on your device. The timer will fire when it reaches the value of the 'timeout' parameter.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>the number of seconds you would like to wait until the timer fires.</p> <code>60</code> Source code in <code>relay/workflow.py</code> <pre><code>async def start_timer(self, timeout: int = 60):\n\"\"\"Starts an unnamed timer, meaning this will be the only timer on your device.\n    The timer will fire when it reaches the value of the 'timeout' parameter.\n\n    Args:\n        timeout (int): the number of seconds you would like to wait until the timer fires.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_start_timer_request',\n        'timeout': timeout\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.stop_timer","title":"<code>stop_timer()</code>  <code>async</code>","text":"<p>Stops an unnamed timer.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def stop_timer(self):\n\"\"\"Stops an unnamed timer.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_stop_timer_request'\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.switch_all_led_off","title":"<code>switch_all_led_off(target)</code>  <code>async</code>","text":"<p>Switches all the LEDs on a device off.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def switch_all_led_off(self, target):\n\"\"\"Switches all the LEDs on a device off.\n\n    Args:\n        target (str): the interaction URN.\n    \"\"\"\n    await self.led_action(target, 'off', {})\n</code></pre>"},{"location":"#relay.workflow.Relay.switch_all_led_on","title":"<code>switch_all_led_on(target, color='0000ff')</code>  <code>async</code>","text":"<p>Switches all the LEDs on a device on to a specified color.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>color</code> <code>str</code> <p>the hex color code you would like the LEDs to be. Defaults to '0000ff'.</p> <code>'0000ff'</code> Source code in <code>relay/workflow.py</code> <pre><code>async def switch_all_led_on(self, target, color: str = '0000ff'):\n\"\"\"Switches all the LEDs on a device on to a specified color.\n\n    Args:\n        target (str): the interaction URN.\n        color (str, optional): the hex color code you would like the LEDs to be. Defaults to '0000ff'.\n    \"\"\"\n    await self.led_action(target, 'static', {'colors': {'ring': color}})\n</code></pre>"},{"location":"#relay.workflow.Relay.switch_led_on","title":"<code>switch_led_on(target, index, color='0000ff')</code>  <code>async</code>","text":"<p>Switches on an LED at a particular index to a specified color.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>index</code> <code>int</code> <p>the index of an LED, numbered 1-12.</p> required <code>color</code> <code>str</code> <p>the hex color code you would like to turn the LED to. Defaults to '0000ff'.</p> <code>'0000ff'</code> Source code in <code>relay/workflow.py</code> <pre><code>async def switch_led_on(self, target, index: int, color: str = '0000ff'):\n\"\"\"Switches on an LED at a particular index to a specified color.\n\n    Args:\n        target (str): the interaction URN.\n        index (int): the index of an LED, numbered 1-12.\n        color (str, optional): the hex color code you would like to turn the LED to. Defaults to '0000ff'.\n    \"\"\"\n    await self.led_action(target, 'static', {'colors': {index: color}})\n</code></pre>"},{"location":"#relay.workflow.Relay.targets_from_source_uri","title":"<code>targets_from_source_uri(source_uri)</code>  <code>staticmethod</code>","text":"<p>Creates a target object from a source URN. Enables the device to perform the desired action after the function has been called.  Used interanlly by interaction functions such as say(), listen(), vibration(), etc.</p> <p>Parameters:</p> Name Type Description Default <code>source_uri</code> <code>str</code> <p>source uri that will be used to create a target.</p> required <p>Returns:</p> Type Description <p>the target that was created from a source URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>@staticmethod\ndef targets_from_source_uri(source_uri: str):\n\"\"\"Creates a target object from a source URN.\n    Enables the device to perform the desired action after the function\n    has been called.  Used interanlly by interaction functions such as\n    say(), listen(), vibration(), etc.\n\n    Args:\n        source_uri (str): source uri that will be used to create a target.\n\n    Returns:\n        the target that was created from a source URN.\n    \"\"\"\n    targets = {\n        'uris': [source_uri]\n    }\n    return targets\n</code></pre>"},{"location":"#relay.workflow.Relay.terminate","title":"<code>terminate()</code>  <code>async</code>","text":"<p>Terminates a workflow.  This method is usually called after your workflow has completed, and you would like to end the workflow by calling end_interaction(), where you can then terminate the workflow.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def terminate(self):\n\"\"\"Terminates a workflow.  This method is usually called\n    after your workflow has completed, and you would like to end the\n    workflow by calling end_interaction(), where you can then terminate\n    the workflow.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_terminate_request'\n    }\n    # there is no response\n    await self._send(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.translate","title":"<code>translate(text, from_lang='en-US', to_lang='es-ES')</code>  <code>async</code>","text":"<p>Translates text from one language to another.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text that you would like to translate.</p> required <code>from_lang</code> <code>str</code> <p>the language that you would like to translate from.</p> <code>'en-US'</code> <code>to_lang</code> <code>str</code> <p>the language that you would like to translate to.</p> <code>'es-ES'</code> <p>Returns:</p> Name Type Description <code>str</code> <p>the translated text.</p> Source code in <code>relay/workflow.py</code> <pre><code>async def translate(self, text: str, from_lang: str = 'en-US', to_lang: str = 'es-ES'):\n\"\"\"Translates text from one language to another.\n\n    Args:\n        text (str): the text that you would like to translate.\n        from_lang (str): the language that you would like to translate from.\n        to_lang (str): the language that you would like to translate to.\n\n    Returns:\n        str: the translated text.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_translate_request',\n        'text': text,\n        'from_lang': from_lang,\n        'to_lang': to_lang\n    }\n    response = await self._send_receive(event)\n    return response['text']\n</code></pre>"},{"location":"#relay.workflow.Relay.unset_var","title":"<code>unset_var(name)</code>  <code>async</code>","text":"<p>Unsets the value of a variable.  </p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the variable whose value you would like to unset.</p> required Source code in <code>relay/workflow.py</code> <pre><code>async def unset_var(self, name: str):\n\"\"\"Unsets the value of a variable.  \n\n    Args:\n        name (str): the name of the variable whose value you would like to unset.\n    \"\"\"\n    event = {\n        '_type': 'wf_api_unset_var_request',\n        'name': name\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Relay.vibrate","title":"<code>vibrate(target, pattern=None)</code>  <code>async</code>","text":"<p>Makes the device vibrate in a particular pattern.  You can specify how many vibrations you would like, the duration of each vibration in milliseconds, and how long you would like the pauses between each vibration to last in milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>the interaction URN.</p> required <code>pattern</code> <code>list</code> <p>an array representing the pattern of your vibration. Defaults to None.</p> <code>None</code> Source code in <code>relay/workflow.py</code> <pre><code>async def vibrate(self, target, pattern: list = None):\n\"\"\"Makes the device vibrate in a particular pattern.  You can specify\n    how many vibrations you would like, the duration of each vibration in\n    milliseconds, and how long you would like the pauses between each vibration to last\n    in milliseconds.\n\n    Args:\n        target (str): the interaction URN.\n        pattern (list, optional): an array representing the pattern of your vibration. Defaults to None.\n    \"\"\"\n    if not pattern:\n        pattern = [100, 500, 500, 500, 500, 500]\n\n    event = {\n        '_type': 'wf_api_vibrate_request',\n        '_target': self.targets_from_source_uri(target),\n        'pattern': pattern\n    }\n    await self._send_receive(event)\n</code></pre>"},{"location":"#relay.workflow.Server","title":"<code>Server</code>","text":"<p>A websocket server that gets connected to when a new workflow is instantiated via a trigger.</p> <p>Events are sent here, and the connection is also used to send actions to the Relay server.</p> Source code in <code>relay/workflow.py</code> <pre><code>class Server:\n\"\"\"\n    A websocket server that gets connected to when a new workflow\n    is instantiated via a trigger.\n\n    Events are sent here, and the connection is also used to send actions to the Relay server.\n    \"\"\"\n\n    def __init__(self, host: str, port: int, **kwargs):\n\"\"\"\n        Args:\n            host: the IP address of the interface that this server should\n             listen on. Typically is \"0.0.0.0\", which represents all interfaces.\n            port: the port number that this server should listen on.\n            **kwargs: see below\n\n        Keyword Args:\n            log_level: sets the threshold level for the logger in this module.\n            log_handler: a log handler object to be added to the logger in this\n             module. To disable logging output, use `logging.NullHandler()`.\n            ssl_key_filename: if an SSLContext is desired for this server,\n             this is the filename where the key in PEM format can be found.\n             Should also use ssl_cert_filename if this is specified.\n            ssl_cert_filename: if an SSLContext is desired for this server,\n             this is the filename where the certificate in PEM format can\n             be found. Should also use ssl_key_filename if this is specified.\n        \"\"\"\n\n        self.host = host\n        self.port = port\n        self.workflows = {}  # {path: workflow}\n        self.conn_count = 0\n        for key in kwargs:\n            if key == 'ssl_key_filename':\n                self.ssl_key_filename = kwargs[key]\n            elif key == 'ssl_cert_filename':\n                self.ssl_cert_filename = kwargs[key]\n            elif key == 'log_level':\n                this_logger = logging.getLogger(__name__)\n                this_logger.setLevel(kwargs[key])\n            elif key == 'log_handler':\n                # if logging.NullHandler() is added then nothing will appear on the console\n                this_logger = logging.getLogger(__name__)\n                this_logger.addHandler(kwargs[key])\n\n    def register(self, workflow, path: str):\n\n        if path in self.workflows:\n            raise ServerException(f'a workflow is already registered at path {path}')\n        self.workflows[path] = workflow\n\n    def start(self):\n\n        custom_headers = {'Server': f'{VERSION}'}\n        if hasattr(self, 'ssl_key_filename') and hasattr(self, 'ssl_cert_filename'):\n            if not os.access(self.ssl_cert_filename, os.R_OK):\n                raise ServerException(f\"can't read ssl_cert_file {self.ssl_cert_filename}\")\n            if not os.access(self.ssl_key_filename, os.R_OK):\n                raise ServerException(f\"can't read ssl_key_file {self.ssl_key_filename}\")\n            ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n            ssl_context.load_cert_chain(self.ssl_cert_filename, self.ssl_key_filename)\n            start_server = websockets.serve(self._handler, self.host, self.port,\n                                            extra_headers=custom_headers, ssl=ssl_context)\n            logger.info(\n                f'Relay workflow server ({VERSION}) listening on {self.host} port {self.port}'\n                f' with ssl_context {ssl_context}')\n        else:\n            start_server = websockets.serve(self._handler, self.host, self.port, extra_headers=custom_headers)\n            logger.info(f'Relay workflow server ({VERSION}) listening on {self.host}'\n                        f' port {self.port} with plaintext')\n\n        asyncio.get_event_loop().run_until_complete(start_server)\n\n        try:\n            asyncio.get_event_loop().run_forever()\n\n        except KeyboardInterrupt:\n            logger.debug('server terminated')\n\n    def total_connections(self):\n        return self.conn_count\n\n    async def _handler(self, websocket, path: str):\n\n        workflow = self.workflows.get(path, None)\n        if workflow:\n            logger.debug(f'handling request on path {path}')\n            relay = Relay(workflow)\n            try:\n                self.conn_count += 1\n                await relay._handle(websocket)\n\n            finally:\n                self.conn_count -= 1\n\n        else:\n            logger.warning(f'ignoring request for unregistered path {path}')\n            await websocket.close()\n</code></pre>"},{"location":"#relay.workflow.Server.__init__","title":"<code>__init__(host, port, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>the IP address of the interface that this server should listen on. Typically is \"0.0.0.0\", which represents all interfaces.</p> required <code>port</code> <code>int</code> <p>the port number that this server should listen on.</p> required <code>**kwargs</code> <p>see below</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>log_level</code> <p>sets the threshold level for the logger in this module.</p> <code>log_handler</code> <p>a log handler object to be added to the logger in this module. To disable logging output, use <code>logging.NullHandler()</code>.</p> <code>ssl_key_filename</code> <p>if an SSLContext is desired for this server, this is the filename where the key in PEM format can be found. Should also use ssl_cert_filename if this is specified.</p> <code>ssl_cert_filename</code> <p>if an SSLContext is desired for this server, this is the filename where the certificate in PEM format can be found. Should also use ssl_key_filename if this is specified.</p> Source code in <code>relay/workflow.py</code> <pre><code>def __init__(self, host: str, port: int, **kwargs):\n\"\"\"\n    Args:\n        host: the IP address of the interface that this server should\n         listen on. Typically is \"0.0.0.0\", which represents all interfaces.\n        port: the port number that this server should listen on.\n        **kwargs: see below\n\n    Keyword Args:\n        log_level: sets the threshold level for the logger in this module.\n        log_handler: a log handler object to be added to the logger in this\n         module. To disable logging output, use `logging.NullHandler()`.\n        ssl_key_filename: if an SSLContext is desired for this server,\n         this is the filename where the key in PEM format can be found.\n         Should also use ssl_cert_filename if this is specified.\n        ssl_cert_filename: if an SSLContext is desired for this server,\n         this is the filename where the certificate in PEM format can\n         be found. Should also use ssl_key_filename if this is specified.\n    \"\"\"\n\n    self.host = host\n    self.port = port\n    self.workflows = {}  # {path: workflow}\n    self.conn_count = 0\n    for key in kwargs:\n        if key == 'ssl_key_filename':\n            self.ssl_key_filename = kwargs[key]\n        elif key == 'ssl_cert_filename':\n            self.ssl_cert_filename = kwargs[key]\n        elif key == 'log_level':\n            this_logger = logging.getLogger(__name__)\n            this_logger.setLevel(kwargs[key])\n        elif key == 'log_handler':\n            # if logging.NullHandler() is added then nothing will appear on the console\n            this_logger = logging.getLogger(__name__)\n            this_logger.addHandler(kwargs[key])\n</code></pre>"},{"location":"#relay.workflow.Workflow","title":"<code>Workflow</code>","text":"Source code in <code>relay/workflow.py</code> <pre><code>class Workflow:\n\n    def __init__(self, name: str):\n        self.name = name\n        self.type_handlers = {}  # {(type, args): func}\n\n    def on_start(self, func):\n\"\"\"\n        A decorator for a handler method for the START event (workflow is starting).\n\n        async def start_handler(workflow:relay.workflow.Workflow, trigger:dict)\n        \"\"\"\n        self.type_handlers['wf_api_start_event'] = func\n\n    def on_stop(self, func):\n\"\"\"\n        A decorator for a handler method for the STOP event (workflow is stopping).\n\n        async def stop_handler(workflow:relay.workflow.Workflow, reason:str)\n        \"\"\"\n        self.type_handlers['wf_api_stop_event'] = func\n\n    def on_prompt(self, func):\n\"\"\"\n        A decorator for a handler method for the PROMPT event (text-to-speech is streaming in).\n\n        async def prompt_handler(workflow:relay.workflow.Workflow, source_uri:str, prompt_type:str)\n        \"\"\"\n        self.type_handlers['wf_api_prompt_event'] = func\n\n    def on_button(self, _func=None, *, button='*', taps='*'):\n\"\"\"\n        A decorator for a handler method for the BUTTON event (the Talk button was pressed).\n\n        async def button_handler(workflow:relay.workflow.Workflow, button:str, taps:str, source_uri:str)\n        \"\"\"\n        def on_button_decorator(func):\n            self.type_handlers['wf_api_button_event', button, taps] = func\n\n        if _func:\n            return on_button_decorator(_func)\n\n        else:\n            return on_button_decorator\n\n    def on_notification(self, _func=None, *, name='*', event='*'):\n\"\"\"\n        A decorator for a handler method for the NOTIFICATION event (a broadcast or alert was sent).\n\n        async def button_handler(workflow:relay.workflow.Workflow, button:str, taps:str, source_uri:str)\n        \"\"\"\n        def on_notification_decorator(func):\n            self.type_handlers['wf_api_notification_event', name, event] = func\n\n        if _func:\n            return on_notification_decorator(_func)\n\n        else:\n            return on_notification_decorator\n\n    def on_timer(self, func):\n        # unnamed timer\n\"\"\"\n        A decorator for a handler method for the TIMER event (the unnamed timer fired).\n\n        async def timer_handler(workflow:relay.workflow.Workflow)\n        \"\"\"\n        self.type_handlers['wf_api_timer_event'] = func\n\n    def on_timer_fired(self, func):\n        # named timer\n\"\"\"\n        A decorator for a handler method for the TIMER_FIRED event (a named timer fired).\n\n        async def timer_fired_handler(workflow:relay.workflow.Workflow, timer_name:str)\n        \"\"\"\n        self.type_handlers['wf_api_timer_fired_event'] = func\n\n    def on_speech(self, func):\n\"\"\"\n        A decorator for a handler method for the SPEECH event (the listen() function is running).\n\n        async def speech_handler(workflow:relay.workflow.Workflow, transcribed_text:str, audio:bytes, language:str,\n                                 request_id:str, source_uri:str)\n        \"\"\"\n        self.type_handlers['wf_api_speech_event'] = func\n\n    def on_progress(self, func):\n\"\"\"\n        A decorator for a handler method for the PROGRESS event (a long running action is being\n        performed across a large number of devices, may get called multiple times).\n\n        async def progress_handler(workflow:relay.workflow.Workflow)\n        \"\"\"\n        self.type_handlers['wf_api_progress_event'] = func\n\n    def on_play_inbox_message(self, func):\n\"\"\"\n        A decorator for a handler method for the PLAY_INBOX_MESSAGE event (a missed message\n        is being played).\n\n        async def play_inbox_message_handler(workflow:relay.workflow.Workflow, action:str)\n        \"\"\"\n        self.type_handlers['wf_api_play_inbox_message_event'] = func\n\n    def on_call_connected(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_CONNECTED event.\n        A call attempt that was ringing, progressing, or incoming is now fully\n        connected. This event can occur on both the caller and the callee.\n\n        async def call_connected_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                         other_device_id:str, other_device_name:str,\n                                         uri:str, onnet:bool,\n                                         start_time_epoch:int, connect_time_epoch:int)\n        \"\"\"\n        self.type_handlers['wf_api_call_connected_event'] = func\n\n    def on_call_disconnected(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_DISCONNECTED event.\n        A call that was once connected has become disconnected. This event can\n        occur on both the caller and the callee.\n\n        async def call_disconnected_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                            other_device_id:str, other_device_name:str,\n                                            uri:str, onnet:bool, reason:str,\n                                            start_time_epoch:int, connect_time_epoch:int, end_time_epoch:int)\n        \"\"\"\n        self.type_handlers['wf_api_call_disconnected_event'] = func\n\n    def on_call_failed(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_FAILED event.\n        A call failed to get connected. This event can occur on both the caller\n        and the callee.\n\n        async def call_failed_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                      other_device_id:str, other_device_name:str,\n                                      uri:str, onnet:bool, reason:str,\n                                      start_time_epoch:int, connect_time_epoch:int, end_time_epoch:int)\n        \"\"\"\n        self.type_handlers['wf_api_call_failed_event'] = func\n\n    def on_call_received(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_RECEIVED event.\n        The device is receiving an inbound call request. This event can occur\n        on the callee.\n\n        async def call_received_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                        other_device_id:str, other_device_name:str,\n                                        uri:str, onnet:bool,\n                                        start_time_epoch:int)\n        \"\"\"\n        self.type_handlers['wf_api_call_received_event'] = func\n\n    def on_call_ringing(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_RINGING event.\n        The device we called is ringing. We are waiting for them to answer.\n        This event can occur on the caller.\n\n        async def call_ringing_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                       other_device_id:str, other_device_name:str,\n                                       uri:str, onnet:bool,\n                                       start_time_epoch:int)\n        \"\"\"\n        self.type_handlers['wf_api_call_ringing_event'] = func\n\n    def on_call_start_request(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_START_REQUEST event.\n        There is a request to make an outbound call. This event can occur on\n        the caller after using the \"Call X\" voice command on the Assistant.\n\n        async def call_start_request_handler(workflow:relay.workflow.Workflow, destination_uri:str)\n        \"\"\"\n        self.type_handlers['wf_api_call_start_request_event'] = func\n\n    def on_call_progressing(self, func):\n\"\"\"\n        A decorator for a handler method for the CALL_PROGRESSING event.\n        The device we called is making progress on getting connected. This may\n        be interspersed with on_call_ringing. This event can occur on the caller.\n\n        async def call_progressing_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                           other_device_id:str, other_device_name:str,\n                                           uri:str, onnet:bool,\n                                           start_time_epoch:int, connect_time_epoch:int)\n        \"\"\"\n        self.type_handlers['wf_api_call_progressing_event'] = func\n\n    def on_sms(self, func):\n\"\"\"\n        A decorator for a handler method for the SMS event (TBD).\n\n        async def sms_handler(workflow:relay.workflow.Workflow, id:str, event:dict)\n        \"\"\"\n        self.type_handlers['wf_api_sms_event'] = func\n\n    def on_incident(self, func):\n\"\"\"\n        A decorator for a handler method for the INCIDENT event (an incident has been created).\n\n        async def incident_handler(workflow:relay.workflow.Workflow, type:str, incident_id:str, reason:str)\n        \"\"\"\n        self.type_handlers['wf_api_incident_event'] = func\n\n    def on_interaction_lifecycle(self, func):\n\"\"\"\n        A decorator for a handler method for the INTERACTION_LIFECYCLE event (an interaction\n        is starting, resuming, or ending).\n\n        async def interaction_lifecycle_handler(workflow:relay.workflow.Workflow, itype:str, source_uri:str, reason:str)\n        \"\"\"\n        self.type_handlers['wf_api_interaction_lifecycle_event'] = func\n\n    def on_resume(self, func):\n\"\"\"\n        A decorator for a handler method for the RESUME event (TBD).\n\n        async def resume_handler(workflow:relay.workflow.Workflow, trigger:dict)\n        \"\"\"\n        self.type_handlers['wf_api_resume_event'] = func\n\n    def get_handler(self, event: dict):\n        t = event['_type']\n\n        # Assume no-arg handler; if not, check the handlers that require args.\n        # For args, check for handler registered with specific values first; if not,\n        # then check variations with wildcard values.\n        h = self.type_handlers.get(t, None)\n        if not h:\n            if t == 'wf_api_button_event':\n                h = self.type_handlers.get((t, event['button'], event['taps']), None)\n                if not h:\n                    # prefer button match over taps\n                    h = self.type_handlers.get((t, event['button'], '*'), None)\n                    if not h:\n                        h = self.type_handlers.get((t, '*', event['taps']), None)\n                        if not h:\n                            h = self.type_handlers.get((t, '*', '*'), None)\n\n            elif t == 'wf_api_notification_event':\n                h = self.type_handlers.get((t, event['name'], event['event']), None)\n                if not h:\n                    # prefer name match over event\n                    h = self.type_handlers.get((t, event['name'], '*'), None)\n                    if not h:\n                        h = self.type_handlers.get((t, '*', event['event']), None)\n                        if not h:\n                            h = self.type_handlers.get((t, '*', '*'), None)\n\n        return h\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_button","title":"<code>on_button(_func=None, *, button='*', taps='*')</code>","text":"<p>A decorator for a handler method for the BUTTON event (the Talk button was pressed).</p> <p>async def button_handler(workflow:relay.workflow.Workflow, button:str, taps:str, source_uri:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_button(self, _func=None, *, button='*', taps='*'):\n\"\"\"\n    A decorator for a handler method for the BUTTON event (the Talk button was pressed).\n\n    async def button_handler(workflow:relay.workflow.Workflow, button:str, taps:str, source_uri:str)\n    \"\"\"\n    def on_button_decorator(func):\n        self.type_handlers['wf_api_button_event', button, taps] = func\n\n    if _func:\n        return on_button_decorator(_func)\n\n    else:\n        return on_button_decorator\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_connected","title":"<code>on_call_connected(func)</code>","text":"<p>A decorator for a handler method for the CALL_CONNECTED event. A call attempt that was ringing, progressing, or incoming is now fully connected. This event can occur on both the caller and the callee.</p> <p>async def call_connected_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,                                  other_device_id:str, other_device_name:str,                                  uri:str, onnet:bool,                                  start_time_epoch:int, connect_time_epoch:int)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_connected(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_CONNECTED event.\n    A call attempt that was ringing, progressing, or incoming is now fully\n    connected. This event can occur on both the caller and the callee.\n\n    async def call_connected_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                     other_device_id:str, other_device_name:str,\n                                     uri:str, onnet:bool,\n                                     start_time_epoch:int, connect_time_epoch:int)\n    \"\"\"\n    self.type_handlers['wf_api_call_connected_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_disconnected","title":"<code>on_call_disconnected(func)</code>","text":"<p>A decorator for a handler method for the CALL_DISCONNECTED event. A call that was once connected has become disconnected. This event can occur on both the caller and the callee.</p> <p>async def call_disconnected_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,                                     other_device_id:str, other_device_name:str,                                     uri:str, onnet:bool, reason:str,                                     start_time_epoch:int, connect_time_epoch:int, end_time_epoch:int)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_disconnected(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_DISCONNECTED event.\n    A call that was once connected has become disconnected. This event can\n    occur on both the caller and the callee.\n\n    async def call_disconnected_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                        other_device_id:str, other_device_name:str,\n                                        uri:str, onnet:bool, reason:str,\n                                        start_time_epoch:int, connect_time_epoch:int, end_time_epoch:int)\n    \"\"\"\n    self.type_handlers['wf_api_call_disconnected_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_failed","title":"<code>on_call_failed(func)</code>","text":"<p>A decorator for a handler method for the CALL_FAILED event. A call failed to get connected. This event can occur on both the caller and the callee.</p> <p>async def call_failed_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,                               other_device_id:str, other_device_name:str,                               uri:str, onnet:bool, reason:str,                               start_time_epoch:int, connect_time_epoch:int, end_time_epoch:int)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_failed(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_FAILED event.\n    A call failed to get connected. This event can occur on both the caller\n    and the callee.\n\n    async def call_failed_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                  other_device_id:str, other_device_name:str,\n                                  uri:str, onnet:bool, reason:str,\n                                  start_time_epoch:int, connect_time_epoch:int, end_time_epoch:int)\n    \"\"\"\n    self.type_handlers['wf_api_call_failed_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_progressing","title":"<code>on_call_progressing(func)</code>","text":"<p>A decorator for a handler method for the CALL_PROGRESSING event. The device we called is making progress on getting connected. This may be interspersed with on_call_ringing. This event can occur on the caller.</p> <p>async def call_progressing_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,                                    other_device_id:str, other_device_name:str,                                    uri:str, onnet:bool,                                    start_time_epoch:int, connect_time_epoch:int)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_progressing(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_PROGRESSING event.\n    The device we called is making progress on getting connected. This may\n    be interspersed with on_call_ringing. This event can occur on the caller.\n\n    async def call_progressing_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                       other_device_id:str, other_device_name:str,\n                                       uri:str, onnet:bool,\n                                       start_time_epoch:int, connect_time_epoch:int)\n    \"\"\"\n    self.type_handlers['wf_api_call_progressing_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_received","title":"<code>on_call_received(func)</code>","text":"<p>A decorator for a handler method for the CALL_RECEIVED event. The device is receiving an inbound call request. This event can occur on the callee.</p> <p>async def call_received_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,                                 other_device_id:str, other_device_name:str,                                 uri:str, onnet:bool,                                 start_time_epoch:int)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_received(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_RECEIVED event.\n    The device is receiving an inbound call request. This event can occur\n    on the callee.\n\n    async def call_received_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                    other_device_id:str, other_device_name:str,\n                                    uri:str, onnet:bool,\n                                    start_time_epoch:int)\n    \"\"\"\n    self.type_handlers['wf_api_call_received_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_ringing","title":"<code>on_call_ringing(func)</code>","text":"<p>A decorator for a handler method for the CALL_RINGING event. The device we called is ringing. We are waiting for them to answer. This event can occur on the caller.</p> <p>async def call_ringing_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,                                other_device_id:str, other_device_name:str,                                uri:str, onnet:bool,                                start_time_epoch:int)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_ringing(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_RINGING event.\n    The device we called is ringing. We are waiting for them to answer.\n    This event can occur on the caller.\n\n    async def call_ringing_handler(workflow:relay.workflow.Workflow, call_id:str, direction:str,\n                                   other_device_id:str, other_device_name:str,\n                                   uri:str, onnet:bool,\n                                   start_time_epoch:int)\n    \"\"\"\n    self.type_handlers['wf_api_call_ringing_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_call_start_request","title":"<code>on_call_start_request(func)</code>","text":"<p>A decorator for a handler method for the CALL_START_REQUEST event. There is a request to make an outbound call. This event can occur on the caller after using the \"Call X\" voice command on the Assistant.</p> <p>async def call_start_request_handler(workflow:relay.workflow.Workflow, destination_uri:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_call_start_request(self, func):\n\"\"\"\n    A decorator for a handler method for the CALL_START_REQUEST event.\n    There is a request to make an outbound call. This event can occur on\n    the caller after using the \"Call X\" voice command on the Assistant.\n\n    async def call_start_request_handler(workflow:relay.workflow.Workflow, destination_uri:str)\n    \"\"\"\n    self.type_handlers['wf_api_call_start_request_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_incident","title":"<code>on_incident(func)</code>","text":"<p>A decorator for a handler method for the INCIDENT event (an incident has been created).</p> <p>async def incident_handler(workflow:relay.workflow.Workflow, type:str, incident_id:str, reason:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_incident(self, func):\n\"\"\"\n    A decorator for a handler method for the INCIDENT event (an incident has been created).\n\n    async def incident_handler(workflow:relay.workflow.Workflow, type:str, incident_id:str, reason:str)\n    \"\"\"\n    self.type_handlers['wf_api_incident_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_interaction_lifecycle","title":"<code>on_interaction_lifecycle(func)</code>","text":"<p>A decorator for a handler method for the INTERACTION_LIFECYCLE event (an interaction is starting, resuming, or ending).</p> <p>async def interaction_lifecycle_handler(workflow:relay.workflow.Workflow, itype:str, source_uri:str, reason:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_interaction_lifecycle(self, func):\n\"\"\"\n    A decorator for a handler method for the INTERACTION_LIFECYCLE event (an interaction\n    is starting, resuming, or ending).\n\n    async def interaction_lifecycle_handler(workflow:relay.workflow.Workflow, itype:str, source_uri:str, reason:str)\n    \"\"\"\n    self.type_handlers['wf_api_interaction_lifecycle_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_notification","title":"<code>on_notification(_func=None, *, name='*', event='*')</code>","text":"<p>A decorator for a handler method for the NOTIFICATION event (a broadcast or alert was sent).</p> <p>async def button_handler(workflow:relay.workflow.Workflow, button:str, taps:str, source_uri:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_notification(self, _func=None, *, name='*', event='*'):\n\"\"\"\n    A decorator for a handler method for the NOTIFICATION event (a broadcast or alert was sent).\n\n    async def button_handler(workflow:relay.workflow.Workflow, button:str, taps:str, source_uri:str)\n    \"\"\"\n    def on_notification_decorator(func):\n        self.type_handlers['wf_api_notification_event', name, event] = func\n\n    if _func:\n        return on_notification_decorator(_func)\n\n    else:\n        return on_notification_decorator\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_play_inbox_message","title":"<code>on_play_inbox_message(func)</code>","text":"<p>A decorator for a handler method for the PLAY_INBOX_MESSAGE event (a missed message is being played).</p> <p>async def play_inbox_message_handler(workflow:relay.workflow.Workflow, action:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_play_inbox_message(self, func):\n\"\"\"\n    A decorator for a handler method for the PLAY_INBOX_MESSAGE event (a missed message\n    is being played).\n\n    async def play_inbox_message_handler(workflow:relay.workflow.Workflow, action:str)\n    \"\"\"\n    self.type_handlers['wf_api_play_inbox_message_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_progress","title":"<code>on_progress(func)</code>","text":"<p>A decorator for a handler method for the PROGRESS event (a long running action is being performed across a large number of devices, may get called multiple times).</p> <p>async def progress_handler(workflow:relay.workflow.Workflow)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_progress(self, func):\n\"\"\"\n    A decorator for a handler method for the PROGRESS event (a long running action is being\n    performed across a large number of devices, may get called multiple times).\n\n    async def progress_handler(workflow:relay.workflow.Workflow)\n    \"\"\"\n    self.type_handlers['wf_api_progress_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_prompt","title":"<code>on_prompt(func)</code>","text":"<p>A decorator for a handler method for the PROMPT event (text-to-speech is streaming in).</p> <p>async def prompt_handler(workflow:relay.workflow.Workflow, source_uri:str, prompt_type:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_prompt(self, func):\n\"\"\"\n    A decorator for a handler method for the PROMPT event (text-to-speech is streaming in).\n\n    async def prompt_handler(workflow:relay.workflow.Workflow, source_uri:str, prompt_type:str)\n    \"\"\"\n    self.type_handlers['wf_api_prompt_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_resume","title":"<code>on_resume(func)</code>","text":"<p>A decorator for a handler method for the RESUME event (TBD).</p> <p>async def resume_handler(workflow:relay.workflow.Workflow, trigger:dict)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_resume(self, func):\n\"\"\"\n    A decorator for a handler method for the RESUME event (TBD).\n\n    async def resume_handler(workflow:relay.workflow.Workflow, trigger:dict)\n    \"\"\"\n    self.type_handlers['wf_api_resume_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_sms","title":"<code>on_sms(func)</code>","text":"<p>A decorator for a handler method for the SMS event (TBD).</p> <p>async def sms_handler(workflow:relay.workflow.Workflow, id:str, event:dict)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_sms(self, func):\n\"\"\"\n    A decorator for a handler method for the SMS event (TBD).\n\n    async def sms_handler(workflow:relay.workflow.Workflow, id:str, event:dict)\n    \"\"\"\n    self.type_handlers['wf_api_sms_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_speech","title":"<code>on_speech(func)</code>","text":"<p>A decorator for a handler method for the SPEECH event (the listen() function is running).</p> <p>async def speech_handler(workflow:relay.workflow.Workflow, transcribed_text:str, audio:bytes, language:str,                          request_id:str, source_uri:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_speech(self, func):\n\"\"\"\n    A decorator for a handler method for the SPEECH event (the listen() function is running).\n\n    async def speech_handler(workflow:relay.workflow.Workflow, transcribed_text:str, audio:bytes, language:str,\n                             request_id:str, source_uri:str)\n    \"\"\"\n    self.type_handlers['wf_api_speech_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_start","title":"<code>on_start(func)</code>","text":"<p>A decorator for a handler method for the START event (workflow is starting).</p> <p>async def start_handler(workflow:relay.workflow.Workflow, trigger:dict)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_start(self, func):\n\"\"\"\n    A decorator for a handler method for the START event (workflow is starting).\n\n    async def start_handler(workflow:relay.workflow.Workflow, trigger:dict)\n    \"\"\"\n    self.type_handlers['wf_api_start_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_stop","title":"<code>on_stop(func)</code>","text":"<p>A decorator for a handler method for the STOP event (workflow is stopping).</p> <p>async def stop_handler(workflow:relay.workflow.Workflow, reason:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_stop(self, func):\n\"\"\"\n    A decorator for a handler method for the STOP event (workflow is stopping).\n\n    async def stop_handler(workflow:relay.workflow.Workflow, reason:str)\n    \"\"\"\n    self.type_handlers['wf_api_stop_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_timer","title":"<code>on_timer(func)</code>","text":"<p>A decorator for a handler method for the TIMER event (the unnamed timer fired).</p> <p>async def timer_handler(workflow:relay.workflow.Workflow)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_timer(self, func):\n    # unnamed timer\n\"\"\"\n    A decorator for a handler method for the TIMER event (the unnamed timer fired).\n\n    async def timer_handler(workflow:relay.workflow.Workflow)\n    \"\"\"\n    self.type_handlers['wf_api_timer_event'] = func\n</code></pre>"},{"location":"#relay.workflow.Workflow.on_timer_fired","title":"<code>on_timer_fired(func)</code>","text":"<p>A decorator for a handler method for the TIMER_FIRED event (a named timer fired).</p> <p>async def timer_fired_handler(workflow:relay.workflow.Workflow, timer_name:str)</p> Source code in <code>relay/workflow.py</code> <pre><code>def on_timer_fired(self, func):\n    # named timer\n\"\"\"\n    A decorator for a handler method for the TIMER_FIRED event (a named timer fired).\n\n    async def timer_fired_handler(workflow:relay.workflow.Workflow, timer_name:str)\n    \"\"\"\n    self.type_handlers['wf_api_timer_fired_event'] = func\n</code></pre>"},{"location":"#relay.workflow.device_id","title":"<code>device_id(gid)</code>","text":"<p>Creates a URN from a device ID.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>str</code> <p>the ID of the device.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the newly constructed URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>def device_id(gid: str):\n\"\"\"Creates a URN from a device ID.\n\n    Args:\n        gid (str): the ID of the device.\n\n    Returns:\n        str: the newly constructed URN.\n    \"\"\"\n    return _construct(DEVICE, ID, urllib.parse.quote(gid))\n</code></pre>"},{"location":"#relay.workflow.device_name","title":"<code>device_name(name)</code>","text":"<p>Creates a URN from a device name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the device.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the newly constructed URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>def device_name(name: str):\n\"\"\"Creates a URN from a device name.\n\n    Args:\n        name (str): the name of the device.\n\n    Returns:\n        str: the newly constructed URN.\n    \"\"\"\n    return _construct(DEVICE, NAME, urllib.parse.quote(name))\n</code></pre>"},{"location":"#relay.workflow.fetch_device","title":"<code>fetch_device(access_token, refresh_token, client_id, subscriber_id, user_id)</code>","text":"<p>A convenience method for getting all the details of a device.</p> <p>This will return quite a bit of data regarding device configuration and state. The result, if the query was successful, should have a large JSON dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>access_token(str)</code> <p>the current access token. Can be a placeholder value</p> required <code>refresh_token(str)</code> <p>the permanent refresh_token that can be used to</p> required <code>client_id(str)</code> <p>the auth_sdk_id as returned from \"relay env\".</p> required <code>subscriber_id(str)</code> <p>the subcriber UUID as returned from \"relay whoami\".</p> required <code>user_id(str)</code> <p>the IMEI of the target device, such as 990007560023456.</p> required Source code in <code>relay/workflow.py</code> <pre><code>def fetch_device(access_token: str, refresh_token: str, client_id: str, subscriber_id: str, user_id: str):\n\"\"\"A convenience method for getting all the details of a device.\n\n    This will return quite a bit of data regarding device configuration and\n    state. The result, if the query was successful, should have a large JSON\n    dictionary.\n\n    Args:\n        access_token(str): the current access token. Can be a placeholder value\n        and this method will generate a new one and return it. If the\n        original value of the access token passed in here has expired,\n        this method will also generate a new one and return it.\n\n        refresh_token(str): the permanent refresh_token that can be used to\n        obtain a new access_token. The caller should treat the refresh\n        token as very sensitive data, and secure it appropriately.\n\n        client_id(str): the auth_sdk_id as returned from \"relay env\".\n\n        subscriber_id(str): the subcriber UUID as returned from \"relay whoami\".\n\n        user_id(str): the IMEI of the target device, such as 990007560023456.\n    \"\"\"\n    url = f'https://{SERVER_HOSTNAME}/relaypro/api/v1/device/{user_id}'\n    headers = {\n        'Authorization': f'Bearer {access_token}',\n        'User-Agent': VERSION\n    }\n    query_params = {'subscriber_id': subscriber_id}\n    response = requests.get(url, headers=headers, params=query_params, timeout=10.0)\n    if response.status_code == 401:\n        logger.debug(f'got 401 on get, trying to get new access token')\n        access_token = _update_access_token(refresh_token, client_id)\n        headers['Authorization'] = f'Bearer {access_token}'\n        response = requests.post(url, headers=headers, params=query_params, timeout=10.0)\n    logger.debug(f'device_info status code={response.status_code}')\n    return response, access_token\n</code></pre>"},{"location":"#relay.workflow.group_id","title":"<code>group_id(gid)</code>","text":"<p>Creates a URN from a group ID.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>str</code> <p>the ID of the group.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the newly constructed URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>def group_id(gid: str):\n\"\"\"Creates a URN from a group ID.\n\n    Args:\n        gid (str): the ID of the group.\n\n    Returns:\n        str: the newly constructed URN.\n    \"\"\"\n    return _construct(GROUP, ID, urllib.parse.quote(gid))\n</code></pre>"},{"location":"#relay.workflow.group_member","title":"<code>group_member(group, device)</code>","text":"<p>Creates a URN for a group member.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>the name of the group that the device belongs to.</p> required <code>device</code> <code>str</code> <p>the device ID or name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the newly constructed URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>def group_member(group: str, device: str):\n\"\"\"Creates a URN for a group member.\n\n    Args:\n        group (str): the name of the group that the device belongs to.\n        device (str): the device ID or name.\n\n    Returns:\n        str: the newly constructed URN.\n    \"\"\"\n    return f'{SCHEME}:{ROOT}:{NAME}:{GROUP}:{urllib.parse.quote(group)}{DEVICE_PATTERN}' + urllib.parse.quote(\n        f'{SCHEME}:{ROOT}:{NAME}:{DEVICE}:{device}')\n</code></pre>"},{"location":"#relay.workflow.group_name","title":"<code>group_name(name)</code>","text":"<p>Creates a URN from a group name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the group.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the newly constructed URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>def group_name(name: str):\n\"\"\"Creates a URN from a group name.\n\n    Args:\n        name (str): the name of the group.\n\n    Returns:\n        str: the newly constructed URN.\n    \"\"\"\n    return _construct(GROUP, NAME, urllib.parse.quote(name))\n</code></pre>"},{"location":"#relay.workflow.interaction_name","title":"<code>interaction_name(name)</code>","text":"<p>Creates a URN from an interaction name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the interaction</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the newly constructed URN.</p> Source code in <code>relay/workflow.py</code> <pre><code>def interaction_name(name: str) -&gt; str:\n\"\"\"Creates a URN from an interaction name.\n\n    Args:\n        name (str): the name of the interaction\n\n    Returns:\n        str: the newly constructed URN.\n    \"\"\"\n    return _construct(INTERACTION, NAME, urllib.parse.quote(name))\n</code></pre>"},{"location":"#relay.workflow.is_interaction_uri","title":"<code>is_interaction_uri(uri)</code>","text":"<p>Checks if the URN is for an interaction.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the device URN.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>true if the URN is an interaction URN, false otherwise.</p> Source code in <code>relay/workflow.py</code> <pre><code>def is_interaction_uri(uri: str):\n\"\"\"Checks if the URN is for an interaction.\n\n    Args:\n        uri (str): the device URN.\n\n    Returns:\n        bool: true if the URN is an interaction URN, false otherwise.\n    \"\"\"\n    if INTERACTION_URI_NAME in uri or INTERACTION_URI_ID in uri:\n        return True\n    return False\n</code></pre>"},{"location":"#relay.workflow.is_relay_uri","title":"<code>is_relay_uri(uri)</code>","text":"<p>Checks if the URN is a Relay URN.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the device, group, or interaction URN.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>true if the URN is a Relay URN, false otherwise.</p> Source code in <code>relay/workflow.py</code> <pre><code>def is_relay_uri(uri: str):\n\"\"\"Checks if the URN is a Relay URN.\n\n    Args:\n        uri (str): the device, group, or interaction URN.\n\n    Returns:\n        bool: true if the URN is a Relay URN, false otherwise.\n    \"\"\"\n    if uri.startswith(f'{SCHEME}:{ROOT}'):\n        return True\n    return False\n</code></pre>"},{"location":"#relay.workflow.parse_device_id","title":"<code>parse_device_id(uri)</code>","text":"<p>Parses out a device ID from a device or interaction URN.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the device or interaction URN that you would like to extract the device ID from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the device ID.</p> Source code in <code>relay/workflow.py</code> <pre><code>def parse_device_id(uri: str):\n\"\"\"Parses out a device ID from a device or interaction URN.\n\n    Args:\n        uri (str): the device or interaction URN that you would like to extract the device ID from.\n\n    Returns:\n        str: the device ID.\n    \"\"\"\n    uri = urllib.parse.unquote(uri)\n    if not is_interaction_uri(uri):\n        scheme, root, id_type, resource_type, gid = uri.split(':')\n        if id_type == ID:\n            return gid\n    elif is_interaction_uri(uri):\n        scheme, root, id_type, resource_type, i_id, i_root, i_id_type, i_resource_type, gid = uri.split(':')\n        if id_type == ID and i_id_type == ID:\n            return gid\n    logger.error('invalid device urn')\n</code></pre>"},{"location":"#relay.workflow.parse_device_name","title":"<code>parse_device_name(uri)</code>","text":"<p>Parses out a device name from a device or interaction URN.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the device or interaction URN that you would like to extract the device name from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the device name.</p> Source code in <code>relay/workflow.py</code> <pre><code>def parse_device_name(uri: str):\n\"\"\"Parses out a device name from a device or interaction URN.\n\n    Args:\n        uri (str): the device or interaction URN that you would like to extract the device name from.\n\n    Returns:\n        str: the device name.\n    \"\"\"\n    uri = urllib.parse.unquote(uri)\n    if not is_interaction_uri(uri):\n        scheme, root, id_type, resource_type, name = uri.split(':')\n        if id_type == NAME:\n            return name\n    elif is_interaction_uri(uri):\n        scheme, root, id_type, resource_type, i_name, i_root, i_id_type, i_resource_type, name = uri.split(':')\n        if id_type == NAME and i_id_type == NAME:\n            return name\n    logger.error('invalid device urn')\n</code></pre>"},{"location":"#relay.workflow.parse_group_id","title":"<code>parse_group_id(uri)</code>","text":"<p>Parses out a group ID from a group URN. </p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the URN that you would like to extract the group ID from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the group ID.</p> Source code in <code>relay/workflow.py</code> <pre><code>def parse_group_id(uri: str):\n\"\"\"Parses out a group ID from a group URN. \n\n    Args:\n        uri (str): the URN that you would like to extract the group ID from.\n\n    Returns:\n        str: the group ID.\n    \"\"\"\n    scheme, root, id_type, resource_type, gid = urllib.parse.unquote(uri).split(':')\n    if id_type == ID and resource_type == GROUP:\n        return gid\n    logger.error('invalid group urn')\n</code></pre>"},{"location":"#relay.workflow.parse_group_name","title":"<code>parse_group_name(uri)</code>","text":"<p>Parses out a group name from a group URN.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the URN that you would like to extract the group name from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the group name.</p> Source code in <code>relay/workflow.py</code> <pre><code>def parse_group_name(uri: str):\n\"\"\"Parses out a group name from a group URN.\n\n    Args:\n        uri (str): the URN that you would like to extract the group name from.\n\n    Returns:\n        str: the group name.\n    \"\"\"\n    scheme, root, id_type, resource_type, name = urllib.parse.unquote(uri).split(':')\n    if id_type == NAME and resource_type == GROUP:\n        return name\n    logger.error('invalid group urn')\n</code></pre>"},{"location":"#relay.workflow.parse_interaction","title":"<code>parse_interaction(uri)</code>","text":"<p>Parses out the name of an interaction from an interaction URN.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the interaction URN that you would like to parse the interaction from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the name of an interaction.</p> Source code in <code>relay/workflow.py</code> <pre><code>def parse_interaction(uri: str):\n\"\"\"Parses out the name of an interaction from an interaction URN.\n\n    Args:\n        uri (str): the interaction URN that you would like to parse the interaction from.\n\n    Returns:\n        str: the name of an interaction.\n    \"\"\"\n    uri = urllib.parse.unquote(uri)\n    if is_interaction_uri(uri):\n        scheme, root, id_type, resource_type, i_name, i_root, i_id_type, i_resource_type, name = uri.split(':')\n        interaction_name, discard = i_name.split('?')\n        return interaction_name\n    logger.error('not an interaction urn')\n</code></pre>"},{"location":"#relay.workflow.trigger_workflow","title":"<code>trigger_workflow(access_token, refresh_token, client_id, workflow_id, subscriber_id, user_id, targets, action_args=None)</code>","text":"<p>A convenience method for sending an HTTP trigger to the Relay server.</p> <p>This generally would be used in a third-party system to start a Relay workflow via an HTTP trigger and optionally pass data to it with action_args.  Under the covers, this uses Python's \"request\" library for using the https protocol.</p> <p>If the access_token has expired and the request gets a 401 response, a new access_token will be automatically generated via the refresh_token, and the request will be resubmitted with the new access_token. Otherwise the refresh token won't be used.</p> <p>This method will return a tuple of (requests.Response, access_token) where you can inspect the http response, and get the updated access_token if it was updated (otherwise the original access_token will be returned).</p> <p>Parameters:</p> Name Type Description Default <code>access_token(str)</code> <p>the current access token. Can be a placeholder value</p> required <code>refresh_token(str)</code> <p>the permanent refresh_token that can be used to</p> required <code>client_id(str)</code> <p>the auth_sdk_id as returned from \"relay env\".</p> required <code>workflow_id(str)</code> <p>the workflow_id as returned from \"relay workflow list\".</p> required <code>subscriber_id(str)</code> <p>the subcriber UUID as returned from \"relay whoami\".</p> required <code>user_id(str)</code> <p>the IMEI of the target device, such as 990007560023456.</p> required <code>targets</code> <code>List[str]</code> <p>the device targets that the workflow should be considered as</p> required <code>action_args</code> <code>optional</code> <p>a dict of any key/value arguments you want</p> <code>None</code> Source code in <code>relay/workflow.py</code> <pre><code>def trigger_workflow(access_token: str, refresh_token: str, client_id: str, workflow_id: str, subscriber_id: str,\n                     user_id: str, targets: List[str], action_args: dict = None):\n\"\"\"A convenience method for sending an HTTP trigger to the Relay server.\n\n    This generally would be used in a third-party system to start a Relay\n    workflow via an HTTP trigger and optionally pass data to it with\n    action_args.  Under the covers, this uses Python's \"request\" library\n    for using the https protocol.\n\n    If the access_token has expired and the request gets a 401 response,\n    a new access_token will be automatically generated via the refresh_token,\n    and the request will be resubmitted with the new access_token. Otherwise\n    the refresh token won't be used.\n\n    This method will return a tuple of (requests.Response, access_token)\n    where you can inspect the http response, and get the updated access_token\n    if it was updated (otherwise the original access_token will be returned).\n\n    Args:\n        access_token(str): the current access token. Can be a placeholder value\n        and this method will generate a new one and return it. If the\n        original value of the access token passed in here has expired,\n        this method will also generate a new one and return it.\n\n        refresh_token(str): the permanent refresh_token that can be used to\n        obtain a new access_token. The caller should treat the refresh\n        token as very sensitive data, and secure it appropriately.\n\n        client_id(str): the auth_sdk_id as returned from \"relay env\".\n\n        workflow_id(str): the workflow_id as returned from \"relay workflow list\".\n        Usually starts with \"wf_\".\n\n        subscriber_id(str): the subcriber UUID as returned from \"relay whoami\".\n\n        user_id(str): the IMEI of the target device, such as 990007560023456.\n\n        targets: the device targets that the workflow should be considered as\n        having been triggered from.\n\n        action_args (optional): a dict of any key/value arguments you want\n        to pass in to the workflow that gets started by this trigger.\n    \"\"\"\n\n    url = f'https://{SERVER_HOSTNAME}/ibot/workflow/{workflow_id}'\n    headers = {\n        'Authorization': f'Bearer {access_token}',\n        'User-Agent': VERSION\n    }\n    query_params = {\n        'subscriber_id': subscriber_id,\n        'user_id': user_id\n    }\n    payload = {\"action\": \"invoke\"}\n    if action_args:\n        payload['action_args'] = action_args\n    if targets:\n        payload['target_device_ids'] = f'{targets}'\n    response = requests.post(url, headers=headers, params=query_params, json=payload, timeout=10.0)\n    # check if access token expired, and if so get a new one from the refresh_token, and resubmit\n    if response.status_code == 401:\n        logger.debug(f'got 401 on workflow trigger, trying to get new access token')\n        access_token = _update_access_token(refresh_token, client_id)\n        headers['Authorization'] = f'Bearer {access_token}'\n        response = requests.post(url, headers=headers, params=query_params, json=payload, timeout=10.0)\n    logger.debug(f'workflow trigger status code={response.status_code}')\n    return response, access_token\n</code></pre>"}]}